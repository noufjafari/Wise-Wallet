/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { Base, markType } from "igniteui-react-core";
import { IDomainChartToolbarProvider_$type } from "./IDomainChartToolbarProvider";
import { ToolCommandStateChanged } from "igniteui-react-core";
import { ValueModeCollection } from "./ValueModeCollection";
import { BrushCollection } from "igniteui-react-core";
import { BrushUtil } from "igniteui-react-core";
/**
 * @hidden
 */
export let DomainChartToolbarProvider = /*@__PURE__*/ (() => {
    class DomainChartToolbarProvider extends Base {
        constructor() {
            super(...arguments);
            this.a = false;
            this._container = null;
            this._commandChanged = null;
        }
        get container() {
            return this._container;
        }
        set container(a) {
            this._container = a;
        }
        get commandChanged() {
            return this._commandChanged;
        }
        set commandChanged(a) {
            this._commandChanged = a;
        }
        getDesiredToolbarActions(a, b) {
            for (let c = 0; c < b.length; c++) {
                this.c(a, b[c]);
            }
            return b;
        }
        c(a, b) {
            if (b.actions != null && b.actions.length > 0) {
                for (let c = 0; c < b.actions.length; c++) {
                    this.c(a, b.actions[c]);
                }
            }
            switch (b.name) {
                case "ShowCrosshairs":
                    {
                        let d = b;
                        d.isChecked = a.a9 != 1;
                    }
                    break;
                case "ShowGridlines":
                    {
                        let e = b;
                        e.isChecked = a.fj;
                    }
                    break;
                case "ShowValueLabels":
                    {
                        let f = b;
                        f.isChecked = a.fj;
                    }
                    break;
                case "ShowLastValueLabel":
                    {
                        let g = b;
                        g.isChecked = a.ft;
                    }
                    break;
                case "MinValue":
                    {
                        if (a.du != null) {
                            let h = b;
                            for (let i = 0; i < a.du.count; i++) {
                                if (a.du._inner[i] == 4) {
                                    h.isChecked = true;
                                    break;
                                }
                            }
                        }
                    }
                    break;
                case "MaxValue":
                    {
                        if (a.du != null) {
                            let j = b;
                            for (let k = 0; k < a.du.count; k++) {
                                if (a.du._inner[k] == 5) {
                                    j.isChecked = true;
                                    break;
                                }
                            }
                        }
                    }
                    break;
                case "Average":
                    {
                        if (a.du != null) {
                            let l = b;
                            for (let m = 0; m < a.du.count; m++) {
                                if (a.du._inner[m] == 6) {
                                    l.isChecked = true;
                                    break;
                                }
                            }
                        }
                    }
                    break;
                case "SeriesAvg":
                    {
                        if (a.du != null) {
                            let n = b;
                            for (let o = 0; o < a.du.count; o++) {
                                if (a.du._inner[o] == 3) {
                                    n.isChecked = true;
                                    break;
                                }
                            }
                        }
                    }
                    break;
            }
            this.d(a, b);
        }
        d(a, b) {
        }
        onToolCommandExecuting(a, b) {
            if (b.commandId == null) {
                return;
            }
            this.a = true;
            switch (b.commandId) {
                case "ZoomReset":
                    this.u(a, b);
                    break;
                case "ZoomIn":
                    this.s(a, b);
                    break;
                case "ZoomOut":
                    this.t(a, b);
                    break;
                case "ShowCrosshairs":
                    this.g(a, b);
                    break;
                case "ShowGridlines":
                    this.i(a, b);
                    break;
                case "MaxValue":
                    this.l(a, b);
                    break;
                case "MinValue":
                    this.m(a, b);
                    break;
                case "Average":
                    this.f(a, b);
                    break;
                case "Exponential":
                    this.h(a, b);
                    break;
                case "Linear":
                    this.j(a, b);
                    break;
                case "Logarithmic":
                    this.k(a, b);
                    break;
                case "NoTrends":
                    this.n(a, b);
                    break;
                case "SeriesAvg":
                    this.o(a, b);
                    break;
                case "ShowValueLabels":
                    this.q(a, b);
                    break;
                case "ShowLastValueLabel":
                    this.p(a, b);
                    break;
            }
            this.a = false;
        }
        onTargetPropertyChanged(a, b, c, d) {
            if (this.a) {
                return;
            }
            switch (b) {
                case "CrosshairsDisplayMode":
                    if (a.a9 == 1) {
                        this.e("ShowCrosshairs", 2, false);
                    }
                    else {
                        this.e("ShowCrosshairs", 2, true);
                    }
                    break;
                case "AutoCalloutsVisible":
                    this.e("ShowValueLabels", 2, a.fj);
                    break;
                case "FinalValueAnnotationsVisible":
                    this.e("ShowLastValueLabel", 2, a.ft);
                    break;
            }
            this.r(a, b, c, d);
        }
        r(a, b, c, d) {
        }
        e(a, b, c) {
            if (this.commandChanged != null) {
                this.commandChanged(((() => {
                    let $ret = new ToolCommandStateChanged();
                    $ret.c = a;
                    $ret.a = b;
                    $ret.b = c;
                    return $ret;
                })()));
            }
        }
        b(a, b) {
            let e = a.argumentsList;
            for (let d = 0; d < e.length; d++) {
                let c = e[d];
                if (c.argumentName == b) {
                    return c.value;
                }
            }
            return false;
        }
        g(a, b) {
            if (this.b(b, "ShowCrosshairs")) {
                a.a9 = 0;
                a.fm = true;
            }
            else {
                a.a9 = 1;
            }
        }
        i(a, b) {
        }
        h(a, b) {
            if (this.b(b, "Exponential")) {
                a.dq = 7;
            }
            else {
                a.dq = 0;
            }
        }
        j(a, b) {
            if (this.b(b, "Linear")) {
                a.dq = 1;
            }
            else {
                a.dq = 0;
            }
        }
        k(a, b) {
            if (this.b(b, "Logarithmic")) {
                a.dq = 6;
            }
            else {
                a.dq = 0;
            }
        }
        n(a, b) {
            if (this.b(b, "NoTrends")) {
                a.dq = 0;
            }
        }
        l(a, b) {
            if (this.b(b, "MaxValue")) {
                if (a.du == null) {
                    a.du = new ValueModeCollection();
                }
                if (a.ai == null) {
                    a.ai = new BrushCollection();
                }
                a.du.add(5);
                a.ai.add(BrushUtil.g(255, 99, 208, 0));
            }
            else {
                for (let c = 0; c < a.du.count; c++) {
                    if (a.du._inner[c] == 5) {
                        a.du.removeAt(c);
                        a.ai.removeAt(c);
                        c--;
                    }
                }
            }
        }
        m(a, b) {
            if (this.b(b, "MinValue")) {
                if (a.du == null) {
                    a.du = new ValueModeCollection();
                }
                if (a.ai == null) {
                    a.ai = new BrushCollection();
                }
                a.du.add(4);
                a.ai.add(BrushUtil.g(255, 246, 93, 80));
            }
            else {
                for (let c = 0; c < a.du.count; c++) {
                    if (a.du._inner[c] == 4) {
                        a.du.removeAt(c);
                        a.ai.removeAt(c);
                        c--;
                    }
                }
            }
        }
        f(a, b) {
            if (this.b(b, "Average")) {
                if (a.du == null) {
                    a.du = new ValueModeCollection();
                }
                if (a.ai == null) {
                    a.ai = new BrushCollection();
                }
                a.du.add(6);
                a.ai.add(BrushUtil.g(255, 248, 173, 118));
            }
            else {
                for (let c = 0; c < a.du.count; c++) {
                    if (a.du._inner[c] == 6) {
                        a.du.removeAt(c);
                        a.ai.removeAt(c);
                        c--;
                    }
                }
            }
        }
        o(a, b) {
            if (this.b(b, "SeriesAvg")) {
                if (a.du == null) {
                    a.du = new ValueModeCollection();
                }
                a.du.add(3);
            }
            else {
                for (let c = 0; c < a.du.count; c++) {
                    if (a.du._inner[c] == 3) {
                        a.du.removeAt(c);
                        c--;
                    }
                }
            }
        }
        q(a, b) {
            if (this.b(b, "ShowValueLabels")) {
                a.fj = true;
            }
            else {
                a.fj = false;
            }
        }
        p(a, b) {
            if (this.b(b, "ShowLastValueLabel")) {
                a.ft = true;
                a.gb = true;
            }
            else {
                a.ft = false;
            }
        }
        s(a, b) {
            a.tq(0.05);
        }
        t(a, b) {
            a.tr(0.05);
        }
        u(a, b) {
            a.tm();
        }
    }
    DomainChartToolbarProvider.$t = /*@__PURE__*/ markType(DomainChartToolbarProvider, 'DomainChartToolbarProvider', Base.$, [IDomainChartToolbarProvider_$type]);
    return DomainChartToolbarProvider;
})();
