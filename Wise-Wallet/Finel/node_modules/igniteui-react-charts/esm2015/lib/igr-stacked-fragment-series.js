import * as React from 'react';
import { delegateCombine, delegateRemove } from "igniteui-react-core";
import { Visibility_$type } from "igniteui-react-core";
import { MarkerType_$type } from "./MarkerType";
import { MarkerFillMode_$type } from "./MarkerFillMode";
import { MarkerOutlineMode_$type } from "./MarkerOutlineMode";
import { IgrPropertyUpdatedEventArgs } from "igniteui-react-core";
import { StackedFragmentSeries } from "./StackedFragmentSeries";
import { fromDoubleCollection, toDoubleCollection, getModifiedProps, isValidProp, brushToString, stringToBrush, ensureBool, colorToString, stringToColor, ensureEnum, toSpinal, initializePropertiesFromCss, NamePatcher, fromPoint, toPoint, fromRect } from "igniteui-react-core";
import { TypeRegistrar } from "igniteui-react-core";
import { SeriesOutlineMode_$type } from './SeriesOutlineMode';
import { LegendItemBadgeMode_$type } from "igniteui-react-core";
import { LegendItemBadgeShape_$type } from "igniteui-react-core";
import { CategoryTransitionInMode_$type } from './CategoryTransitionInMode';
import { TransitionInSpeedType_$type } from './TransitionInSpeedType';
import { PenLineCap_$type } from "igniteui-react-core";
/**
 * Represents a non-visual child of StackedSeriesBase.
*/
export class IgrStackedFragmentSeries extends React.Component {
    createImplementation() {
        return new StackedFragmentSeries();
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        this._propertyUpdated = null;
        this._propertyUpdated_wrapped = null;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
    }
    componentDidMount() {
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        return null;
    }
    provideRenderer(renderer) {
        this._renderer = renderer;
        this.i.visualSeriesLink.provideRenderer(renderer);
    }
    /**
     * @hidden
     */
    get i() {
        return this._implementation;
    } /**
                                 * @hidden
                                 */
    static _createFromInternal(internal) {
        if (!internal) {
            return null;
        }
        if (!internal.$type) {
            return null;
        }
        let name = internal.$type.name;
        let externalName = "Igr" + name;
        if (!TypeRegistrar.isRegistered(externalName)) {
            return null;
        }
        return TypeRegistrar.create(externalName);
    }
    /**
 * Gets or sets the ItemsSource property for the current series object. Normally you will want to provide data to the parent series instead.
 * But if you have data as individual columns, it can be assigned here. The data must be aligned and have the same number of items for each fragment.
*/
    get dataSource() {
        return this.i.itemsSource;
    }
    set dataSource(v) {
        this.i.itemsSource = v;
    }
    /**
     * Gets or sets the brush of the stacked fragment.
    */
    get brush() {
        return brushToString(this.i.kc);
    }
    set brush(v) {
        this.i.kc = stringToBrush(v);
    }
    /**
     * Gets the actual brush used by the series.
    */
    get actualBrush() {
        return brushToString(this.i.j7);
    }
    set actualBrush(v) {
        this.i.j7 = stringToBrush(v);
    }
    /**
     * Gets or sets a collection of Double values that indicate the pattern of dashes and gaps that
     * is used to outline the current series object.
    */
    get dashArray() {
        return fromDoubleCollection(this.i.kl);
    }
    set dashArray(v) {
        this.i.kl = toDoubleCollection(v);
    }
    /**
     * Gets or sets whether drop shadow should be enabled for this series.
    */
    get isDropShadowEnabled() {
        return this.i.at;
    }
    set isDropShadowEnabled(v) {
        this.i.at = ensureBool(v);
    }
    /**
     * Gets whether drop shadow is actually enabled for this series.
    */
    get actualIsDropShadowEnabled() {
        return this.i.ak;
    }
    set actualIsDropShadowEnabled(v) {
        this.i.ak = ensureBool(v);
    }
    /**
     * Gets or sets the shadow blur.
     * This property is ignored when
     * StackedFragmentSeries.UseSingleShadow is set to true.
    */
    get shadowBlur() {
        return this.i.bz;
    }
    set shadowBlur(v) {
        this.i.bz = +v;
    }
    /**
     * Gets the actual shadow blur used by the series.
    */
    get actualShadowBlur() {
        return this.i.bg;
    }
    set actualShadowBlur(v) {
        this.i.bg = +v;
    }
    /**
     * Gets or sets the drop shadow color.
    */
    get shadowColor() {
        return colorToString(this.i.kj);
    }
    set shadowColor(v) {
        this.i.kj = stringToColor(v);
    }
    /**
     * Gets actual the drop shadow color used by the series.
    */
    get actualShadowColor() {
        return colorToString(this.i.ki);
    }
    set actualShadowColor(v) {
        this.i.ki = stringToColor(v);
    }
    /**
     * Gets or sets whether drop shadow is applied to the whole StackedFragmentSeries visual or to each of the individual shapes forming the StackedFragmentSeries.
     * When this property is set to true, no
     * StackedFragmentSeries.ShadowBlur is applied.
    */
    get useSingleShadow() {
        return this.i.a3;
    }
    set useSingleShadow(v) {
        this.i.a3 = ensureBool(v);
    }
    /**
     * Gets whether drop shadow is actually applied to the whole StackedFragmentSeries visual or to each of the individual shapes forming the StackedFragmentSeries.
    */
    get actualUseSingleShadow() {
        return this.i.aq;
    }
    set actualUseSingleShadow(v) {
        this.i.aq = ensureBool(v);
    }
    /**
     * Gets or sets the drop shadow x-offset.
    */
    get shadowOffsetX() {
        return this.i.b0;
    }
    set shadowOffsetX(v) {
        this.i.b0 = +v;
    }
    /**
     * Gets the actual drop shadow x-offset applied to the series.
    */
    get actualShadowOffsetX() {
        return this.i.bh;
    }
    set actualShadowOffsetX(v) {
        this.i.bh = +v;
    }
    /**
     * Gets or sets the drop shadow y-offset.
    */
    get shadowOffsetY() {
        return this.i.b1;
    }
    set shadowOffsetY(v) {
        this.i.b1 = +v;
    }
    /**
     * Gets the actual drop shadow y-offset applied to the series.
    */
    get actualShadowOffsetY() {
        return this.i.bi;
    }
    set actualShadowOffsetY(v) {
        this.i.bi = +v;
    }
    /**
     * The style of the end points of any lines or polylines representing this series.
     * Not every series type has a line at which it would be appropriate to display an end cap, so this property does not affect every series type.  LineSeries, for example, is affected by EndCap, but ColumnSeries is not.
    */
    get lineCap() {
        return this.i.kp;
    }
    set lineCap(v) {
        this.i.kp = ensureEnum(PenLineCap_$type, v);
    }
    /**
     * Gets the actual end cap used by the series.
    */
    get actualLineCap() {
        return this.i.kn;
    }
    set actualLineCap(v) {
        this.i.kn = ensureEnum(PenLineCap_$type, v);
    }
    /**
     * Gets or sets the LegendItemBadgeTemplate property.
     * The legend item badge is created according to the LegendItemBadgeTemplate on-demand by
     * the series object itself.
    */
    get legendItemBadgeTemplate() {
        return this.i.g9;
    }
    set legendItemBadgeTemplate(v) {
        this.i.g9 = v;
    }
    /**
     * Gets the actual legend item badge template used by the series.
    */
    get actualLegendItemBadgeTemplate() {
        return this.i.g6;
    }
    set actualLegendItemBadgeTemplate(v) {
        this.i.g6 = v;
    }
    /**
     * Gets or sets the LegendItemTemplate property.
     * The legend item control content is created according to the LegendItemTemplate on-demand by
     * the series object itself.
    */
    get legendItemTemplate() {
        return this.i.ha;
    }
    set legendItemTemplate(v) {
        this.i.ha = v;
    }
    /**
     * Gets the actual legend item template used by the series.
    */
    get actualLegendItemTemplate() {
        return this.i.g7;
    }
    set actualLegendItemTemplate(v) {
        this.i.g7 = v;
    }
    /**
     * Gets or sets the legend item visibility for the current series object.
    */
    get legendItemVisibility() {
        return this.i.k7;
    }
    set legendItemVisibility(v) {
        this.i.k7 = ensureEnum(Visibility_$type, v);
    }
    /**
     * Gets the actual visibility of the legend items in the series.
    */
    get actualLegendItemVisibility() {
        return this.i.k5;
    }
    set actualLegendItemVisibility(v) {
        this.i.k5 = ensureEnum(Visibility_$type, v);
    }
    /**
     * Gets or sets the type of legend badge representing the current series in a legend.
     * This property will be ignored when the LegendItemTemplate or LegendItemBadgeTemplate property is set on the series
    */
    get legendItemBadgeShape() {
        return this.i.r;
    }
    set legendItemBadgeShape(v) {
        this.i.r = ensureEnum(LegendItemBadgeShape_$type, v);
    }
    /**
     * Gets or sets the mode of legend badge representing the current series in a legend.
     * This property will be ignored when the LegendItemTemplate or LegendItemBadgeTemplate property is set on the series
    */
    get legendItemBadgeMode() {
        return this.i.p;
    }
    set legendItemBadgeMode(v) {
        this.i.p = ensureEnum(LegendItemBadgeMode_$type, v);
    }
    /**
     * Gets the actual LegendItemBadgeShape of the series.
    */
    get actualLegendItemBadgeShape() {
        return this.i.q;
    }
    set actualLegendItemBadgeShape(v) {
        this.i.q = ensureEnum(LegendItemBadgeShape_$type, v);
    }
    /**
     * Gets the actual LegendItemBadgeMode of the series.
    */
    get actualLegendItemBadgeMode() {
        return this.i.o;
    }
    set actualLegendItemBadgeMode(v) {
        this.i.o = ensureEnum(LegendItemBadgeMode_$type, v);
    }
    /**
     * Gets or sets the brush that specifies how the current series object's marker interiors are painted.
    */
    get markerBrush() {
        return brushToString(this.i.kd);
    }
    set markerBrush(v) {
        this.i.kd = stringToBrush(v);
    }
    /**
     * Gets the actual marker brush of the series.
    */
    get actualMarkerBrush() {
        return brushToString(this.i.j8);
    }
    set actualMarkerBrush(v) {
        this.i.j8 = stringToBrush(v);
    }
    /**
     * Gets or sets the brush that specifies how the current series object's marker outlines are painted.
    */
    get markerOutline() {
        return brushToString(this.i.ke);
    }
    set markerOutline(v) {
        this.i.ke = stringToBrush(v);
    }
    /**
     * Gets the actual marker outline of the series.
    */
    get actualMarkerOutline() {
        return brushToString(this.i.j9);
    }
    set actualMarkerOutline(v) {
        this.i.j9 = stringToBrush(v);
    }
    /**
     * Gets or sets the MarkerTemplate for the current series object.
    */
    get markerTemplate() {
        return this.i.hb;
    }
    set markerTemplate(v) {
        this.i.hb = v;
    }
    /**
     * Gets the actual marker template used by the series.
    */
    get actualMarkerTemplate() {
        return this.i.g8;
    }
    set actualMarkerTemplate(v) {
        this.i.g8 = v;
    }
    /**
     * Gets or sets the marker type for the current series object.
     * If the MarkerTemplate property is set, the setting of the MarkerType property will be ignored.
    */
    get markerType() {
        return this.i.x;
    }
    set markerType(v) {
        this.i.x = ensureEnum(MarkerType_$type, v);
    }
    /**
     * Gets the actual marker type set used in the series.
    */
    get actualMarkerType() {
        return this.i.w;
    }
    set actualMarkerType(v) {
        this.i.w = ensureEnum(MarkerType_$type, v);
    }
    /**
     * Gets or sets whether the marker fill is based on the marker outline of the series rather than the marker brushes collection.
    */
    get markerFillMode() {
        return this.i.t;
    }
    set markerFillMode(v) {
        this.i.t = ensureEnum(MarkerFillMode_$type, v);
    }
    /**
     * Gets whether the marker fill is based on the marker outline of the series rather than the marker brushes collection.
    */
    get actualMarkerFillMode() {
        return this.i.s;
    }
    set actualMarkerFillMode(v) {
        this.i.s = ensureEnum(MarkerFillMode_$type, v);
    }
    /**
     * Gets or sets whether the marker outline is based on the marker brush of the series rather than the marker outlines collection.
    */
    get markerOutlineMode() {
        return this.i.v;
    }
    set markerOutlineMode(v) {
        this.i.v = ensureEnum(MarkerOutlineMode_$type, v);
    }
    /**
     * Gets whether the marker outline is based on the marker brush of the series rather than the marker outlines collection.
    */
    get actualMarkerOutlineMode() {
        return this.i.u;
    }
    set actualMarkerOutlineMode(v) {
        this.i.u = ensureEnum(MarkerOutlineMode_$type, v);
    }
    /**
     * Gets or sets the Name of the stacked fragment.
    */
    get name() {
        return this.i.en;
    }
    set name(v) {
        this.i.en = v;
    }
    /**
     * Gets or sets the Opacity of the stacked fragment.
    */
    get opacity() {
        return this.i.bw;
    }
    set opacity(v) {
        this.i.bw = +v;
    }
    /**
     * Gets the series opacity.
    */
    get actualOpacity() {
        return this.i.bd;
    }
    set actualOpacity(v) {
        this.i.bd = +v;
    }
    /**
     * Gets or sets the brush to use for the outline of the series.
     * Some series types, such as LineSeries, do not display outlines.  Therefore, this property does not affect some charts.
    */
    get outline() {
        return brushToString(this.i.kg);
    }
    set outline(v) {
        this.i.kg = stringToBrush(v);
    }
    /**
     * Gets the series outline.
    */
    get actualOutline() {
        return brushToString(this.i.kb);
    }
    set actualOutline(v) {
        this.i.kb = stringToBrush(v);
    }
    /**
     * Gets or sets the AreaFillOpacity of the stacked fragment. This property only applies for area-like series.
    */
    get areaFillOpacity() {
        return this.i.bk;
    }
    set areaFillOpacity(v) {
        this.i.bk = +v;
    }
    /**
     * Gets the series ActualAreaFillOpacity.  This property only applies for area-like series.
    */
    get actualAreaFillOpacity() {
        return this.i.a9;
    }
    set actualAreaFillOpacity(v) {
        this.i.a9 = +v;
    }
    /**
     * Gets or sets the opacity to use for the marker fills.
    */
    get markerFillOpacity() {
        return this.i.bu;
    }
    set markerFillOpacity(v) {
        this.i.bu = +v;
    }
    /**
     * Gets the actual opacity to use for hte marker fills.
    */
    get actualMarkerFillOpacity() {
        return this.i.bb;
    }
    set actualMarkerFillOpacity(v) {
        this.i.bb = +v;
    }
    /**
     * Gets or sets the outline mode to use for the fragment.
    */
    get outlineMode() {
        return this.i.aa;
    }
    set outlineMode(v) {
        this.i.aa = ensureEnum(SeriesOutlineMode_$type, v);
    }
    /**
     * Gets the actual outline mode to use for the fragment.
    */
    get actualOutlineMode() {
        return this.i.z;
    }
    set actualOutlineMode(v) {
        this.i.z = ensureEnum(SeriesOutlineMode_$type, v);
    }
    /**
     * Gets or sets the target opacity to fade to for fade style highlighting.
    */
    get highlightingFadeOpacity() {
        return this.i.bt;
    }
    set highlightingFadeOpacity(v) {
        this.i.bt = +v;
    }
    /**
     * Gets the actual target opacity to fade to for fade style highlighting.
    */
    get actualHighlightingFadeOpacity() {
        return this.i.ba;
    }
    set actualHighlightingFadeOpacity(v) {
        this.i.ba = +v;
    }
    /**
     * Gets or sets the x-radius of the ellipse that is used to round the corners of the column. This only applies to Bar and Column series.
    */
    get radiusX() {
        return this.i.bx;
    }
    set radiusX(v) {
        this.i.bx = +v;
    }
    /**
     * Gets the actual corner radius of the series
    */
    get actualRadiusX() {
        return this.i.be;
    }
    set actualRadiusX(v) {
        this.i.be = +v;
    }
    /**
     * Gets whether the spline part is considered to be part of the range
    */
    get actualIsSplineShapePartOfRange() {
        return this.i.am;
    }
    set actualIsSplineShapePartOfRange(v) {
        this.i.am = ensureBool(v);
    }
    /**
     * Gets or sets whether to include the spline shape in the axis range requested of the axis.
    */
    get isSplineShapePartOfRange() {
        return this.i.av;
    }
    set isSplineShapePartOfRange(v) {
        this.i.av = ensureBool(v);
    }
    /**
     * Gets or sets the y-radius of the ellipse that is used to round the corners of the column. This only applies to Bar and Column series.
    */
    get radiusY() {
        return this.i.by;
    }
    set radiusY(v) {
        this.i.by = +v;
    }
    /**
     * Gets the actual corner radius of the series
    */
    get actualRadiusY() {
        return this.i.bf;
    }
    set actualRadiusY(v) {
        this.i.bf = +v;
    }
    /**
     * Gets or sets the width of the current series object's line thickness.
    */
    get thickness() {
        return this.i.b2;
    }
    set thickness(v) {
        this.i.b2 = +v;
    }
    /**
     * Gets or sets the thickness of this stacked fragment.
    */
    get actualThickness() {
        return this.i.bj;
    }
    set actualThickness(v) {
        this.i.bj = +v;
    }
    /**
     * Gets or sets the width of the current series object's marker thickness.
    */
    get markerThickness() {
        return this.i.bv;
    }
    set markerThickness(v) {
        this.i.bv = +v;
    }
    /**
     * Gets actual marker thickness of this stacked fragment.
    */
    get actualMarkerThickness() {
        return this.i.bc;
    }
    set actualMarkerThickness(v) {
        this.i.bc = +v;
    }
    /**
     * Gets or sets the Title property.
     * The legend item control is created according to the Title on-demand by
     * the series object itself.
    */
    get title() {
        return this.i.ch;
    }
    set title(v) {
        this.i.ch = v;
    }
    /**
     * Gets or sets the EasingFunction used to morph the current series.
    */
    get transitionEasingFunction() {
        return this.i.ah;
    }
    set transitionEasingFunction(v) {
        this.i.ah = v;
    }
    /**
     * Gets or sets the duration of the current series's morph.
    */
    get transitionDuration() {
        return this.i.cb;
    }
    set transitionDuration(v) {
        this.i.cb = +v;
    }
    /**
     * Gets or sets the duration of the current series's transition in morph.
    */
    get transitionInDuration() {
        return this.i.cc;
    }
    set transitionInDuration(v) {
        this.i.cc = +v;
    }
    /**
     * Gets or sets the EasingFunction used to morph the current series during the initial transition.
    */
    get transitionInEasingFunction() {
        return this.i.ai;
    }
    set transitionInEasingFunction(v) {
        this.i.ai = v;
    }
    /**
     * Gets or sets the method by which to animate the data into the chart when the chart data source is swapped.
     * Note: Transitions are not currently supported for stacked series.
    */
    get transitionInMode() {
        return this.i.n;
    }
    set transitionInMode(v) {
        this.i.n = ensureEnum(CategoryTransitionInMode_$type, v);
    }
    /**
     * Gets or sets whether the series should transition into the plot area when a new data source is assigned.
     * Note: Transitions are not currently supported for stacked series.
    */
    get isTransitionInEnabled() {
        return this.i.aw;
    }
    set isTransitionInEnabled(v) {
        this.i.aw = ensureBool(v);
    }
    /**
     * Gets or sets the duration of the current series's transition in morph.
    */
    get transitionInSpeedType() {
        return this.i.ad;
    }
    set transitionInSpeedType(v) {
        this.i.ad = ensureEnum(TransitionInSpeedType_$type, v);
    }
    /**
     * Gets the the resolved value of whether transition in is enabled.
    */
    get actualIsTransitionInEnabled() {
        return this.i.an;
    }
    set actualIsTransitionInEnabled(v) {
        this.i.an = ensureBool(v);
    }
    /**
     * Gets the resolved transition in duration
    */
    get actualTransitionInDuration() {
        return this.i.b5;
    }
    set actualTransitionInDuration(v) {
        this.i.b5 = +v;
    }
    /**
     * Gets the series transition easing function.
    */
    get actualTransitionInMode() {
        return this.i.m;
    }
    set actualTransitionInMode(v) {
        this.i.m = ensureEnum(CategoryTransitionInMode_$type, v);
    }
    /**
     * Gets the series transition easing function.
    */
    get actualTransitionInSpeedType() {
        return this.i.ac;
    }
    set actualTransitionInSpeedType(v) {
        this.i.ac = ensureEnum(TransitionInSpeedType_$type, v);
    }
    /**
     * Gets the series transition easing function.
    */
    get actualTransitionInEasingFunction() {
        return this.i.ag;
    }
    set actualTransitionInEasingFunction(v) {
        this.i.ag = v;
    }
    /**
     * Gets the series transition easing function.
    */
    get actualTransitionEasingFunction() {
        return this.i.af;
    }
    set actualTransitionEasingFunction(v) {
        this.i.af = v;
    }
    /**
     * Gets the series transition duration.
    */
    get actualTransitionDuration() {
        return this.i.b4;
    }
    set actualTransitionDuration(v) {
        this.i.b4 = +v;
    }
    /**
     * Gets or sets the value mapping property for the current series object.
    */
    get valueMemberPath() {
        return this.i.fg;
    }
    set valueMemberPath(v) {
        this.i.fg = v;
    }
    /**
     * Gets or sets the label displayed before series value in the Data Legend.
    */
    get valueMemberAsLegendLabel() {
        return this.i.fc;
    }
    set valueMemberAsLegendLabel(v) {
        this.i.fc = v;
    }
    /**
     * Gets or sets the unit displayed after series value in the Data Legend.
    */
    get valueMemberAsLegendUnit() {
        return this.i.fe;
    }
    set valueMemberAsLegendUnit(v) {
        this.i.fe = v;
    }
    /**
     * Gets the label displayed before series value in the Data Legend.
    */
    get actualValueMemberAsLegendLabel() {
        return this.i.dt;
    }
    set actualValueMemberAsLegendLabel(v) {
        this.i.dt = v;
    }
    /**
     * Gets the unit displayed after series value in the Data Legend.
    */
    get actualValueMemberAsLegendUnit() {
        return this.i.dv;
    }
    set actualValueMemberAsLegendUnit(v) {
        this.i.dv = v;
    }
    /**
     * Gets or sets the Visibility of the stacked fragment.
    */
    get visibility() {
        return this.i.k8;
    }
    set visibility(v) {
        this.i.k8 = ensureEnum(Visibility_$type, v);
    }
    /**
     * Gets the actual visibility of the stacked fragment.
    */
    get actualVisibility() {
        return this.i.k6;
    }
    set actualVisibility(v) {
        this.i.k6 = ensureEnum(Visibility_$type, v);
    }
    /**
     * Gets the resolved brush used between the local series and the parent series.
    */
    get parentOrLocalBrush() {
        return brushToString(this.i.kh);
    }
    set parentOrLocalBrush(v) {
        this.i.kh = stringToBrush(v);
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("StackedFragmentSeries");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    /**
 * Gets the item index associated with the specified world position

*/
    getItemIndex(world) {
        let iv = this.i.b6(toPoint(world));
        return (iv);
    }
    /**
     * Gets the item that is the best match for the specified world coordinates.
    
    * @param world  * The world coordinates to use.
    */
    getItem(world) {
        let iv = this.i.cf(toPoint(world));
        return (iv);
    }
    getPreviousOrExactIndex(world, skipUnknowns) {
        let iv = this.i.b9(toPoint(world), skipUnknowns);
        return (iv);
    }
    getNextOrExactIndex(world, skipUnknowns) {
        let iv = this.i.b8(toPoint(world), skipUnknowns);
        return (iv);
    }
    getSeriesValue(world, useInterpolation, skipUnknowns) {
        let iv = this.i.br(toPoint(world), useInterpolation, skipUnknowns);
        return (iv);
    }
    getSeriesValuePosition(world, useInterpolation, skipUnknowns) {
        let iv = this.i.kv(toPoint(world), useInterpolation, skipUnknowns);
        return fromPoint(iv);
    }
    /**
     * If possible, will return the best available value bounding box within the series that has the best value match for the world position provided.
    
    * @param world  * The world coordinate for which to get a value bounding box for
    */
    getSeriesValueBoundingBox(world) {
        let iv = this.i.kz(toPoint(world));
        return fromRect(iv);
    }
    /**
     * If possible, will return the best available value marker bounding box within the series that has the best value match for the world position provided.
    
    * @param world  * The world coordinates for which to get a value marker bounding box for
    */
    getSeriesValueMarkerBoundingBox(world) {
        let iv = this.i.k1(toPoint(world));
        return fromRect(iv);
    }
    getSeriesHighValue(world, useInterpolation, skipUnknowns) {
        let iv = this.i.bn(toPoint(world), useInterpolation, skipUnknowns);
        return (iv);
    }
    getSeriesHighValuePosition(world, useInterpolation, skipUnknowns) {
        let iv = this.i.kr(toPoint(world), useInterpolation, skipUnknowns);
        return fromPoint(iv);
    }
    getSeriesLowValue(world, useInterpolation, skipUnknowns) {
        let iv = this.i.bp(toPoint(world), useInterpolation, skipUnknowns);
        return (iv);
    }
    getSeriesLowValuePosition(world, useInterpolation, skipUnknowns) {
        let iv = this.i.kt(toPoint(world), useInterpolation, skipUnknowns);
        return fromPoint(iv);
    }
    getSeriesValuePositionFromSeriesPixel(mouse, useInterpolation, skipUnknowns) {
        let iv = this.i.kw(toPoint(mouse), useInterpolation, skipUnknowns);
        return fromPoint(iv);
    }
    getSeriesValueFromSeriesPixel(mouse, useInterpolation, skipUnknowns) {
        let iv = this.i.bs(toPoint(mouse), useInterpolation, skipUnknowns);
        return (iv);
    }
    /**
     * For a category plotted series, returns the current width of the items within the categories. This only returns a value if the items have some form of width (e.g. columns, bars, etc.) otherwise 0 is returned.
    
    */
    getItemSpan() {
        let iv = this.i.bm();
        return (iv);
    }
    /**
     * Converts a point from coordinates within the series plot area to a world position within axis space.
    
    * @param seriesPoint  * The pixel location within the plot area of the series.
    */
    toWorldPosition(seriesPoint) {
        let iv = this.i.kx(toPoint(seriesPoint));
        return fromPoint(iv);
    }
    /**
     * Converts a point from world coordinates to coordinates within the viewport of the series.
    
    * @param world  * The world position from which to convert.
    */
    fromWorldPosition(world) {
        let iv = this.i.kq(toPoint(world));
        return fromPoint(iv);
    }
    /**
     * Requests that the provided item should be brought into view if possible.
    
    * @param item  * The item to attempt to bring into view.
    */
    scrollIntoView(item) {
        let iv = this.i.az(item);
        return (iv);
    }
    /**
     * Gets the effective viewport, adjusted to account for margins and other factors.
    
    */
    getEffectiveViewport() {
        let iv = this.i.ky();
        return fromRect(iv);
    }
    /**
     * Notifies the series that a visual property has changed, requiring a visual update.
    
    */
    notifyVisualPropertiesChanged() {
        this.i.fk();
    }
    /**
     * Simulates a pointer hover over the series surface.
    
    * @param point  * The pointer position relative to the series viewport over which to hover.
    */
    simulateHover(point) {
        this.i.fp(toPoint(point));
    }
    /**
     * Moves the cursor point to the provided world position. Some series may react to the current cursor position.
    
    * @param point  * The cursor point, in world coordinates.
    */
    moveCursorPoint(point) {
        this.i.fj(toPoint(point));
    }
    replayTransitionIn() {
        this.i.fo();
    }
    /**
     * Event raised when a property (including "effective" and non-dependency property) value changes.
    */
    get propertyUpdated() {
        return this._propertyUpdated;
    }
    set propertyUpdated(ev) {
        if (this._propertyUpdated_wrapped !== null) {
            this.i.propertyUpdated = delegateRemove(this.i.propertyUpdated, this._propertyUpdated_wrapped);
            this._propertyUpdated_wrapped = null;
            this._propertyUpdated = null;
        }
        this._propertyUpdated = ev;
        this._propertyUpdated_wrapped = (o, e) => {
            let outerArgs = new IgrPropertyUpdatedEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforePropertyUpdated) {
                this.beforePropertyUpdated(this, outerArgs);
            }
            if (this._propertyUpdated) {
                this._propertyUpdated(this, outerArgs);
            }
        };
        this.i.propertyUpdated = delegateCombine(this.i.propertyUpdated, this._propertyUpdated_wrapped);
        ;
    }
}
