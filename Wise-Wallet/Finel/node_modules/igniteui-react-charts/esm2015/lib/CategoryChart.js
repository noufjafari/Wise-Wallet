/*
THIS INFRAGISTICS ULTIMATE SOFTWARE LICENSE  AGREEMENT ("AGREEMENT") LOCATED HERE:
https://www.infragistics.com/legal/license/igultimate-la
https://www.infragistics.com/legal/license/igultimate-eula
GOVERNS THE LICENSING, INSTALLATION AND USE OF INFRAGISTICS SOFTWARE. BY DOWNLOADING AND/OR INSTALLING AND USING INFRAGISTICS SOFTWARE:  you are indicating that you have read and understand this Agreement, and agree to be legally bound by it on behalf of the yourself and your company.
*/
import { XYChart } from "./XYChart";
import { typeCast, runOn, delegateCombine, enumGetBox, markType, TypeRegistrar, getInstanceType } from "igniteui-react-core";
import { CategoryChartType_$type } from "./CategoryChartType";
import { CategorySeriesMarkerCollisionAvoidance_$type } from "./CategorySeriesMarkerCollisionAvoidance";
import { CategoryTransitionInMode_$type } from "./CategoryTransitionInMode";
import { TransitionInSpeedType_$type } from "./TransitionInSpeedType";
import { AutoMarginsAndAngleUpdateMode_$type } from "./AutoMarginsAndAngleUpdateMode";
import { AxisRangeBufferMode_$type } from "./AxisRangeBufferMode";
import { CategoryXAxis } from "./CategoryXAxis";
import { List$1 } from "igniteui-react-core";
import { DataSeriesType_$type } from "igniteui-react-core";
import { NumericYAxis } from "./NumericYAxis";
import { IDataSeriesAdapterRule_$type } from "igniteui-react-core";
import { SimpleCategorySeriesRule } from "igniteui-react-core";
import { SubCollectionsRule } from "igniteui-react-core";
import { DVContainer } from "igniteui-react-core";
import { Brush } from "igniteui-react-core";
import { AxisDefaults } from "./AxisDefaults";
import { Defaults } from "./Defaults";
import { Series } from "./Series";
import { HorizontalAnchoredCategorySeries } from "./HorizontalAnchoredCategorySeries";
import { ArrayExtension } from "igniteui-react-core";
import { AxisLabelSettings } from "./AxisLabelSettings";
import { DeviceUtils } from "igniteui-react-core";
import { CategoryChartMockDataGenerator } from "./CategoryChartMockDataGenerator";
import { stringIsNullOrEmpty } from "igniteui-react-core";
/**
 * @hidden
 */
export let CategoryChart = /*@__PURE__*/ (() => {
    class CategoryChart extends XYChart {
        r9() {
            super.r9();
            if (this.dataChart == null) {
                return;
            }
            let a = this.dataChart.cu.j.e();
            this.ac2 = a.d;
            this.ac3 = a.e;
            if (this.acc == null) {
                this.acc = a.k;
            }
            if (this.acj == null) {
                this.acj = a.k;
            }
            this.yb = 0;
            this.ack = AxisDefaults.h;
            this.acn = null;
            this.acg = AxisDefaults.g;
            this.acd = null;
            this.xu = AxisDefaults.f;
            this.ach = AxisDefaults.j;
            this.xv = AxisDefaults.e;
            this.fm = true;
            this.fn = true;
            this.a9 = 0;
            this.h9 = Defaults.j;
            this.uo = Defaults.ae;
            this.uj = Defaults.af;
            this.uk = Defaults.ag;
            this.ad4 = true;
        }
        sb(a, b) {
            super.sb(a, b);
            a.hs = this.afl;
            a.ch = this.adp;
        }
        sy(a, b, c) {
            super.sy(a, b, c);
            switch (a) {
                case "TransitionInDuration":
                    this.ry((d) => d.hs = this.afl);
                    break;
                case "TransitionInEasingFunction":
                    this.ry((d) => d.ch = this.adp);
                    break;
            }
        }
        get afl() {
            return this.afj;
        }
        set afl(a) {
            let b = this.afl;
            if (a != b) {
                this.afj = a;
                this.sv("TransitionInDuration", b, this.afl);
            }
        }
        get adp() {
            return this.ado;
        }
        set adp(a) {
            let b = this.adp;
            if (a != b) {
                this.ado = a;
                this.sv("TransitionInEasingFunction", b, this.adp);
            }
        }
        afr() {
            let cvd_ = this.j9();
            cvd_.scaleByViewport();
            return (cvd_.serialize());
        }
        r4(a) {
            super.r4(a);
            a.ds = this.fh;
            a.ur = this.ad5;
            a.uu = this.ad6;
            a.vh = this.aeu;
            a.vi = this.aev;
            a.tw = this.ac5;
        }
        sa(a, b) {
            super.sa(a, b);
            let c = typeCast(HorizontalAnchoredCategorySeries.$, a);
            if (c == null) {
                return;
            }
            c.tr = this.adb;
            c.so = this.ad4;
            c.r8 = this.add;
            c.cb = this.adn;
            c.trendLineBrush = ArrayExtension.getModulus$1(Brush.$, this.ah, b);
            c.trendLineType = this.dq;
            c.trendLineThickness = this.i7;
            c.ql = this.cr(a, b);
            if (a.d6) {
                a.ms(ArrayExtension.getModulus$1(Brush.$, this.ac2, b), ArrayExtension.getModulus$1(Brush.$, this.ac3, b));
            }
        }
        ade() {
            return new CategoryXAxis();
        }
        adi() {
            return new NumericYAxis();
        }
        rn() {
            this.xAxis = this.ade();
            this.xAxis.name = "xAxis";
            let a = this.xAxis;
            a.propertyChanged = delegateCombine(a.propertyChanged, runOn(this, this.agt));
            this.yAxis = this.adi();
            this.yAxis.name = "yAxis";
            let b = this.yAxis;
            b.propertyChanged = delegateCombine(b.propertyChanged, runOn(this, this.agu));
            if (this.xAxis.ay == null) {
                this.xAxis.ay = new AxisLabelSettings();
            }
            if (this.yAxis.ay == null) {
                this.yAxis.ay = new AxisLabelSettings();
            }
        }
        abc(a) {
            super.abc(a);
            a.k9 = this.ad8;
            a.lc = this.aea;
            a.b0 = this.ad9;
        }
        aba(a) {
            super.aba(a);
            a.b0 = this.ad7;
            a.zoomMaximumCategoryRange = this.ae8;
            a.zoomToCategoryRange = this.afa;
            a.zoomToCategoryStart = this.afb;
            a.zoomMaximumItemSpan = this.ae9;
            a.zoomToItemSpan = this.afc;
        }
        get_b1() {
            return 0;
        }
        get b1() {
            return this.get_b1();
        }
        get ac9() {
            return this.ac8;
        }
        set ac9(a) {
            if (a != this.ac8) {
                let b = this.ac9;
                this.ac8 = a;
                this.sv("ChartType", enumGetBox(CategoryChartType_$type, b), enumGetBox(CategoryChartType_$type, this.ac9));
            }
        }
        get adb() {
            return this.ada;
        }
        set adb(a) {
            let b = this.adb;
            if (a != b) {
                this.ada = a;
                this.sv("MarkerCollisionAvoidance", enumGetBox(CategorySeriesMarkerCollisionAvoidance_$type, b), enumGetBox(CategorySeriesMarkerCollisionAvoidance_$type, this.adb));
            }
        }
        get ad3() {
            return this.ads;
        }
        set ad3(a) {
            let b = this.ad3;
            if (a != b) {
                this.ads = a;
                this.sv("IsSplineShapePartOfRange", b, this.ad3);
            }
        }
        get ad4() {
            return this.adt;
        }
        set ad4(a) {
            let b = this.ad4;
            if (a != b) {
                this.adt = a;
                this.sv("IsTransitionInEnabled", b, this.ad4);
            }
        }
        get add() {
            return this.adc;
        }
        set add(a) {
            let b = this.add;
            if (a != b) {
                this.adc = a;
                this.sv("TransitionInMode", enumGetBox(CategoryTransitionInMode_$type, b), enumGetBox(CategoryTransitionInMode_$type, this.add));
            }
        }
        get adn() {
            return this.adm;
        }
        set adn(a) {
            let b = this.adn;
            if (a != b) {
                this.adm = a;
                this.sv("TransitionInSpeedType", enumGetBox(TransitionInSpeedType_$type, b), enumGetBox(TransitionInSpeedType_$type, this.adn));
            }
        }
        get ae3() {
            return this.aeg;
        }
        set ae3(a) {
            let b = this.ae3;
            if (a != b) {
                this.aeg = a;
                this.sv("XAxisInterval", b, this.ae3);
            }
        }
        get ae6() {
            return this.aej;
        }
        set ae6(a) {
            let b = this.ae6;
            if (a != b) {
                this.aej = a;
                this.sv("XAxisMinorInterval", b, this.ae6);
            }
        }
        get ae2() {
            return this.aef;
        }
        set ae2(a) {
            let b = this.ae2;
            if (a != b) {
                this.aef = a;
                this.sv("XAxisGap", b, this.ae2);
            }
        }
        get ae5() {
            return this.aei;
        }
        set ae5(a) {
            let b = this.ae5;
            if (a != b) {
                this.aei = a;
                this.sv("XAxisMinimumGapSize", b, this.ae5);
            }
        }
        get ae4() {
            return this.aeh;
        }
        set ae4(a) {
            let b = this.ae4;
            if (a != b) {
                this.aeh = a;
                this.sv("XAxisMaximumGap", b, this.ae4);
            }
        }
        get ae7() {
            return this.aek;
        }
        set ae7(a) {
            let b = this.ae7;
            if (a != b) {
                this.aek = a;
                this.sv("XAxisOverlap", b, this.ae7);
            }
        }
        get aff() {
            return this.aeq;
        }
        set aff(a) {
            let b = this.aff;
            if (a != b) {
                this.aeq = a;
                this.sv("YAxisInterval", b, this.aff);
            }
        }
        get ac5() {
            return this.ac4;
        }
        set ac5(a) {
            let b = this.ac5;
            if (a != b) {
                this.ac4 = a;
                this.sv("AutoMarginAndAngleUpdateMode", enumGetBox(AutoMarginsAndAngleUpdateMode_$type, b), enumGetBox(AutoMarginsAndAngleUpdateMode_$type, this.ac5));
            }
        }
        agv() {
            if (this.dataChart != null) {
                this.dataChart.w2();
            }
        }
        get ad5() {
            return this.adu;
        }
        set ad5(a) {
            let b = this.ad5;
            if (a != b) {
                this.adu = a;
                this.sv("ShouldAutoExpandMarginForInitialLabels", b, this.ad5);
            }
        }
        get ad6() {
            return this.adv;
        }
        set ad6(a) {
            let b = this.ad6;
            if (a != b) {
                this.adv = a;
                this.sv(CategoryChart.af0, b, this.ad6);
            }
        }
        get aeu() {
            return this.aed;
        }
        set aeu(a) {
            let b = this.aeu;
            if (a != b) {
                this.aed = a;
                this.sv("AutoExpandMarginExtraPadding", b, this.aeu);
            }
        }
        get aev() {
            return this.aee;
        }
        set aev(a) {
            let b = this.aev;
            if (a != b) {
                this.aee = a;
                this.sv("AutoExpandMarginMaximumValue", b, this.aev);
            }
        }
        get aea() {
            return this.adz;
        }
        set aea(a) {
            let b = this.aea;
            if (a != b) {
                this.adz = a;
                this.sv("YAxisFavorLabellingScaleEnd", b, this.aea);
            }
        }
        get ad7() {
            return this.adw;
        }
        set ad7(a) {
            let b = this.ad7;
            if (a != b) {
                this.adw = a;
                this.sv(CategoryChart.af5, b, this.ad7);
            }
        }
        get ad9() {
            return this.ady;
        }
        set ad9(a) {
            let b = this.ad9;
            if (a != b) {
                this.ady = a;
                this.sv(CategoryChart.agj, b, this.ad9);
            }
        }
        get ac7() {
            return this.ac6;
        }
        set ac7(a) {
            let b = this.ac7;
            if (a != b) {
                this.ac6 = a;
                this.sv("YAxisAutoRangeBufferMode", enumGetBox(AxisRangeBufferMode_$type, b), enumGetBox(AxisRangeBufferMode_$type, this.ac7));
            }
        }
        get aeb() {
            return this.ad0;
        }
        set aeb(a) {
            let b = this.aeb;
            if (a != b) {
                this.ad0 = a;
                this.sv("YAxisIsLogarithmic", b, this.aeb);
            }
        }
        get afm() {
            return this.afk;
        }
        set afm(a) {
            let b = this.afm;
            if (a != b) {
                this.afk = a;
                this.sv("YAxisLogarithmBase", b, this.afm);
            }
        }
        get afh() {
            return this.aes;
        }
        set afh(a) {
            let b = this.afh;
            if (a != b) {
                this.aes = a;
                this.sv("YAxisMinimumValue", b, this.afh);
            }
        }
        get afg() {
            return this.aer;
        }
        set afg(a) {
            let b = this.afg;
            if (a != b) {
                this.aer = a;
                this.sv("YAxisMaximumValue", b, this.afg);
            }
        }
        get afi() {
            return this.aet;
        }
        set afi(a) {
            let b = this.afi;
            if (a != b) {
                this.aet = a;
                this.sv("YAxisMinorInterval", b, this.afi);
            }
        }
        get ae1() {
            return this.xAxis.mv;
        }
        get ae0() {
            return this.xAxis.mu;
        }
        aex() {
            return this.ae1;
        }
        aez() {
            return this.afe;
        }
        aew() {
            return this.ae0;
        }
        aey() {
            return this.afd;
        }
        get afe() {
            return this.yAxis.lw;
        }
        get afd() {
            return this.yAxis.lv;
        }
        get ac2() {
            return this.ac0;
        }
        set ac2(a) {
            let b = this.ac2;
            if (a != b) {
                this.ac0 = a;
                this.sv("NegativeBrushes", b, this.ac2);
            }
        }
        get ac3() {
            return this.ac1;
        }
        set ac3(a) {
            let b = this.ac3;
            if (a != b) {
                this.ac1 = a;
                this.sv("NegativeOutlines", b, this.ac3);
            }
        }
        get ad8() {
            return this.adx;
        }
        set ad8(a) {
            let b = this.ad8;
            if (a != b) {
                this.adx = a;
                this.sv("YAxisAbbreviateLargeNumbers", b, this.ad8);
            }
        }
        get ae8() {
            return this.ael;
        }
        set ae8(a) {
            let b = this.ae8;
            if (a != b) {
                this.ael = a;
                this.sv("XAxisZoomMaximumCategoryRange", b, this.ae8);
            }
        }
        get ae9() {
            return this.aem;
        }
        set ae9(a) {
            let b = this.ae9;
            if (a != b) {
                this.aem = a;
                this.sv("XAxisZoomMaximumItemSpan", b, this.ae9);
            }
        }
        get afa() {
            return this.aen;
        }
        set afa(a) {
            let b = this.afa;
            if (a != b) {
                this.aen = a;
                this.sv("XAxisZoomToCategoryRange", b, this.afa);
            }
        }
        get afb() {
            return this.aeo;
        }
        set afb(a) {
            let b = this.afb;
            if (a != b) {
                this.aeo = a;
                this.sv("XAxisZoomToCategoryStart", b, this.afb);
            }
        }
        get afc() {
            return this.aep;
        }
        set afc(a) {
            let b = this.afc;
            if (a != b) {
                this.aep = a;
                this.sv("XAxisZoomToItemSpan", b, this.afc);
            }
        }
        get ad1() {
            return this.adq;
        }
        set ad1(a) {
            let b = this.ad1;
            if (a != b) {
                this.adq = a;
                this.sv("IsCategoryHighlightingEnabled", b, this.ad1);
            }
        }
        get ad2() {
            return this.adr;
        }
        set ad2(a) {
            let b = this.ad2;
            if (a != b) {
                this.adr = a;
                this.sv("IsItemHighlightingEnabled", b, this.ad2);
            }
        }
        constructor() {
            super();
            this.afj = 1000;
            this.ado = null;
            this.ac8 = 9;
            this.ada = 1;
            this.ads = false;
            this.adt = true;
            this.adc = 0;
            this.adm = 0;
            this.aeg = 0;
            this.aej = 0;
            this.aef = 0;
            this.aei = 0;
            this.aeh = 1;
            this.aek = 0;
            this.aeq = NaN;
            this.ac4 = 1;
            this.adu = true;
            this.adv = true;
            this.aed = DeviceUtils.g(2);
            this.aee = DeviceUtils.g(60);
            this.adz = true;
            this.adw = true;
            this.ady = false;
            this.ac6 = 0;
            this.ad0 = false;
            this.afk = 10;
            this.aes = NaN;
            this.aer = NaN;
            this.aet = 0;
            this.ac0 = null;
            this.ac1 = null;
            this.adx = true;
            this.ael = 3;
            this.aem = NaN;
            this.aen = NaN;
            this.aeo = NaN;
            this.aep = NaN;
            this.adq = false;
            this.adr = false;
            this.aec = null;
            DVContainer.instance.registerIfLoaded("CategoryChartToolbarFactoryManager");
            this.rr();
        }
        get_gr() {
            let a = new List$1(DataSeriesType_$type, 0);
            if (TypeRegistrar.isRegistered("AreaSeries")) {
                a.add(2);
            }
            if (TypeRegistrar.isRegistered("ColumnSeries")) {
                a.add(1);
            }
            if (TypeRegistrar.isRegistered("LineSeries")) {
                a.add(0);
            }
            if (TypeRegistrar.isRegistered("PointSeries")) {
                a.add(10);
            }
            if (TypeRegistrar.isRegistered("SplineSeries")) {
                a.add(6);
            }
            if (TypeRegistrar.isRegistered("SplineAreaSeries")) {
                a.add(7);
            }
            if (TypeRegistrar.isRegistered("StepAreaSeries")) {
                a.add(5);
            }
            if (TypeRegistrar.isRegistered("StepLineSeries")) {
                a.add(4);
            }
            if (TypeRegistrar.isRegistered("WaterfallSeries")) {
                a.add(8);
            }
            return a;
        }
        get gr() {
            return this.get_gr();
        }
        gv() {
            if (this.aec == null) {
                this.aec = CategoryChartMockDataGenerator.a();
            }
            return this.aec;
        }
        cq(a) {
            if (a != null) {
                let b = super.cq(a);
                if (b == 2) {
                    if (a.d5 && this.fx) {
                        return 13;
                    }
                }
            }
            return super.cq(a);
        }
        cs(a) {
            if (a != null) {
                let b = super.cq(a);
                if (b == 2) {
                    if (a.d5 && this.fx) {
                        return 13;
                    }
                }
            }
            return super.cs(a);
        }
        get_ge() {
            return this.xAxis != null && this.xAxis.categoryMode != 0;
        }
        agt(a, b) {
            switch (b.propertyName) {
                case "ActualMinimum":
                    this.s5("XAxisActualMinimum");
                    break;
                case "ActualMaximum":
                    this.s5("XAxisActualMaximum");
                    break;
            }
        }
        agu(a, b) {
            switch (b.propertyName) {
                case "ActualMinimumValue":
                    this.s5("YAxisActualMinimum");
                    break;
                case "ActualMaximumValue":
                    this.s5("YAxisActualMaximum");
                    break;
            }
        }
        th() {
            super.th();
            this.xAxis.fz = this.yl == null ? XYChart.yx(this.xAxis, this.bd.dataSeries) : this.yl;
            this.xAxis.itemsSource = this.dataChart != null && this.dataChart.series.count > 0 ? this.dataChart.series._inner[0].itemsSource : null;
            if (this.ad5) {
                this.sn((a) => a.w2());
            }
        }
        get xAxis() {
            return this._xAxis;
        }
        set xAxis(a) {
            this._xAxis = a;
        }
        get yAxis() {
            return this._yAxis;
        }
        set yAxis(a) {
            this._yAxis = a;
        }
        adh(a, b) {
            switch (a) {
                case 2: return this.c3(1);
                case 3: return this.c3(10);
                case 0: return this.c3(0);
                case 1: return this.c3(2);
                case 6: return this.c3(6);
                case 7: return this.c3(7);
                case 4: return this.c3(4);
                case 5: return this.c3(5);
                case 8: return this.c3(8);
                case 9: return this.adg(b);
                default: return this.c3(1);
            }
        }
        adg(a) {
            return this.c3(a);
        }
        bc(a) {
            switch (this.ac9) {
                case 1: return 2;
                case 0: return 0;
                case 3: return 10;
                case 6: return 6;
                case 7: return 7;
                case 5: return 5;
                case 4: return 4;
                case 8: return 8;
                case 9: return a.suggestedSeries;
                default:
                case 2: return 1;
            }
        }
        c1(a, b) {
            let c = this.adh(this.ac9, a.suggestedSeries);
            c.uc = a.findMatchingHint(0).path;
            c.xAxis = this.xAxis;
            c.yAxis = this.yAxis;
            return c;
        }
        tf(a) {
            if (a.suggestedSecondaryAxis == 2) {
                this.yAxis.lh = true;
                this.yAxis.l8 = 10;
            }
        }
        ti() {
            this.yAxis.lh = this.aeb;
            this.yAxis.l8 = this.afm;
        }
        get_gq() {
            return ((() => {
                let $ret = new List$1(IDataSeriesAdapterRule_$type, 0);
                $ret.add(new SimpleCategorySeriesRule());
                $ret.add(new SubCollectionsRule());
                return $ret;
            })());
        }
        get gq() {
            return this.get_gq();
        }
        rj(a, b) {
            let c = typeCast(HorizontalAnchoredCategorySeries.$, a);
            if (c != null) {
                c.tr = this.adb;
                c.ql = this.cr(a, b);
            }
        }
        agr(a) {
            this.ags((b, c) => a(b));
        }
        ags(a) {
            if (this.dataChart == null) {
                return;
            }
            for (let b = 0; b < this.dataChart.series.count; b++) {
                let c = typeCast(HorizontalAnchoredCategorySeries.$, this.dataChart.series._inner[b]);
                if (c == null) {
                    continue;
                }
                a(c, b);
            }
        }
        v3() {
            return this.xAxis;
        }
        v4() {
            return this.yAxis;
        }
        adk() {
            return this.c3(30);
        }
        adl() {
            return this.c3(31);
        }
        gn(a, b) {
            let c = super.gn(a, b);
            if (c != null) {
                let d = new List$1(Series.$, 0);
                if (this.adq) {
                    d.add(this.adk());
                }
                if (this.adr) {
                    d.add(this.adl());
                }
                for (let e = 0; e < d.count; e++) {
                    let f = d._inner[e];
                    f.name = a + getInstanceType(f).typeName;
                    c.add(f);
                }
            }
            return c;
        }
        a7() {
            if (this.a6 == 0) {
                return 1;
            }
            else {
                return this.a6;
            }
        }
        tn(a, b, c) {
            super.tn(a, b, c);
            if (this.bd.dataSeries.count > 0) {
                if (stringIsNullOrEmpty(this.lm)) {
                    this.b3.setXMemberPath(a, c.getMemberPathFor(16));
                }
                if (stringIsNullOrEmpty(this.lo)) {
                    this.b3.setYMemberPath(a, c.getMemberPathFor(0));
                }
                if (stringIsNullOrEmpty(this.li)) {
                    this.b3.setLabelMemberPath(a, c.getMemberPathFor(0));
                }
                if (stringIsNullOrEmpty(this.lf)) {
                    this.b3.setContentMemberPath(a, c.getMemberPathFor(0));
                }
            }
        }
        f0() {
            if (this.a9 == 4 || this.a9 == 3) {
                return true;
            }
            else if (this.a9 == 0) {
                if (this.ac9 == 2 || this.ac9 == 8) {
                    return false;
                }
                else if (this.ac9 == 9 && this.bd != null && this.bd.dataSeries != null && this.bd.dataSeries.count > 0) {
                    let a = this.bd.dataSeries._inner[0].suggestedSeries;
                    if (a == 1 || a == 8) {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }
        get_f6() {
            return DVContainer.instance.checkLoaded("CategoryChartToolbarFactoryManager");
        }
        sv(a, b, c) {
            super.sv(a, b, c);
            switch (a) {
                case "ChartType":
                    this.th();
                    break;
                case "MarkerCollisionAvoidance":
                    this.agr((d) => d.tr = this.adb);
                    break;
                case "IsTransitionInEnabled":
                    this.agr((d) => d.so = this.ad4);
                    break;
                case "IsSplineShapePartOfRange":
                    this.agr((d) => {
                        if (d.ej) {
                            d.mt(this.ad3);
                        }
                    });
                    break;
                case "TransitionInMode":
                    this.agr((d) => d.r8 = this.add);
                    break;
                case "TransitionInSpeedType":
                    this.agr((d) => d.cb = this.adn);
                    break;
                case "XAxisInterval":
                    this.xAxis.mq = this.ae3;
                    break;
                case "XAxisMinorInterval":
                    this.xAxis.mr = this.ae6;
                    break;
                case "XAxisGap":
                    this.xAxis.k0 = this.ae2;
                    break;
                case "XAxisOverlap":
                    this.xAxis.k9 = this.ae7;
                    break;
                case "XAxisMinimumGapSize":
                    this.xAxis.k8 = this.ae5;
                    break;
                case "XAxisMaximumGap":
                    this.xAxis.k7 = this.ae4;
                    break;
                case "XAxisZoomMaximumCategoryRange":
                    this.xAxis.zoomMaximumCategoryRange = this.ae8;
                    break;
                case "XAxisZoomMaximumItemSpan":
                    this.xAxis.zoomMaximumItemSpan = this.ae9;
                    break;
                case "XAxisZoomToCategoryRange":
                    this.xAxis.zoomToCategoryRange = this.afa;
                    break;
                case "XAxisZoomToCategoryStart":
                    this.xAxis.zoomToCategoryStart = this.afb;
                    break;
                case "XAxisZoomToItemSpan":
                    this.xAxis.zoomToItemSpan = this.afc;
                    break;
                case "YAxisInterval":
                    this.yAxis.l0 = this.aff;
                    break;
                case "YAxisFavorLabellingScaleEnd":
                    this.yAxis.lc = this.aea;
                    break;
                case "YAxisAutoRangeBufferMode":
                    this.yAxis.kt = this.ac7;
                    break;
                case "YAxisIsLogarithmic":
                    this.yAxis.lh = this.aeb;
                    break;
                case "YAxisLogarithmBase":
                    this.yAxis.l8 = this.afm;
                    break;
                case "YAxisMinimumValue":
                    this.yAxis.l4 = this.afh;
                    break;
                case "YAxisMaximumValue":
                    this.yAxis.l3 = this.afg;
                    break;
                case "YAxisMinorInterval":
                    this.yAxis.l5 = this.afi;
                    break;
                case "NegativeBrushes":
                case "NegativeOutlines":
                    this.ags((d, e) => {
                        if (d.d6) {
                            d.ms(ArrayExtension.getModulus$1(Brush.$, this.ac2, e), ArrayExtension.getModulus$1(Brush.$, this.ac3, e));
                        }
                    });
                    break;
                case "YAxisAbbreviateLargeNumbers":
                    this.abj((d) => d.k9 = this.ad8);
                    break;
                case "IsCategoryHighlightingEnabled":
                case "IsItemHighlightingEnabled":
                    this.th();
                    break;
                case "AutoMarginAndAngleUpdateMode":
                    this.sn((d) => d.tw = this.ac5);
                    break;
                case "ShouldAutoExpandMarginForInitialLabels":
                    this.sn((d) => d.ur = this.ad5);
                    break;
                case CategoryChart.af0:
                    this.sn((d) => d.uu = this.ad6);
                    break;
                case "AutoExpandMarginExtraPadding":
                    this.sn((d) => d.vh = this.aeu);
                    break;
                case "AutoExpandMarginMaximumValue":
                    this.sn((d) => d.vi = this.aev);
                    break;
                case CategoryChart.af5:
                    this.abf((d) => d.b0 = this.ad7, a);
                    break;
                case CategoryChart.agj:
                    this.abj((d) => d.b0 = this.ad9);
                    break;
            }
        }
    }
    CategoryChart.$t = /*@__PURE__*/ markType(CategoryChart, 'CategoryChart', XYChart.$);
    CategoryChart.af0 = "ShouldConsiderAutoRotationForInitialLabels";
    CategoryChart.af5 = "XAxisEnhancedIntervalPreferMoreCategoryLabels";
    CategoryChart.agj = "YAxisEnhancedIntervalPreferMoreCategoryLabels";
    return CategoryChart;
})();
