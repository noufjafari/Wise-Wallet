import * as React from 'react';
import { HorizontalAlignment_$type } from "igniteui-react-core";
import { UnknownValuePlotting_$type } from "igniteui-react-core";
import { TrendLineType_$type } from "igniteui-react-core";
import { IgrChartSeriesEventArgs } from './igr-chart-series-event-args';
import { arrayFindByName, brushToString, stringToBrush, toBrushCollection, fromBrushCollection, fromRect, toRect, ensureBool, ensureEnum, isValidProp, getModifiedProps, toSpinal, initializePropertiesFromCss, NamePatcher } from "igniteui-react-core";
import { MarkerType_$type } from "./MarkerType";
import { delegateCombine, delegateRemove } from "igniteui-react-core";
import { IgrDomainChartSeriesPointerEventArgs } from './igr-domain-chart-series-pointer-event-args';
import { MarkerTypeCollection as MarkerTypeCollection_internal } from './MarkerTypeCollection';
import { IgrMarkerTypeCollection } from './igr-marker-type-collection';
import { SyncableObservableCollection$1 } from "igniteui-react-core";
import { ToolTipType_$type } from "./ToolTipType";
import { CrosshairsDisplayMode_$type } from "./CrosshairsDisplayMode";
import { IgrCalloutStyleUpdatingEventArgs } from "./igr-callout-style-updating-event-args";
import { ComputedPlotAreaMarginMode_$type } from './ComputedPlotAreaMarginMode';
import { SeriesHighlightingMode_$type } from './SeriesHighlightingMode';
import { SeriesHighlightingBehavior_$type } from './SeriesHighlightingBehavior';
import { LegendHighlightingMode_$type } from './LegendHighlightingMode';
import { SeriesOutlineMode_$type } from './SeriesOutlineMode';
import { MarkerOutlineMode_$type } from './MarkerOutlineMode';
import { MarkerFillMode_$type } from './MarkerFillMode';
import { MarkerAutomaticBehavior_$type } from './MarkerAutomaticBehavior';
import { LegendItemBadgeMode_$type } from "igniteui-react-core";
import { LegendItemBadgeShape_$type } from "igniteui-react-core";
import { DataAbbreviationMode_$type } from "igniteui-react-core";
import { DataLegendValueMode_$type } from "igniteui-react-core";
import { DataLegendHeaderDateMode_$type } from "igniteui-react-core";
import { DataLegendHeaderTimeMode_$type } from "igniteui-react-core";
import { DataLegendUnitsMode_$type } from "igniteui-react-core";
import { DataLegendLabelMode_$type } from "igniteui-react-core";
import { DataLegendSummaryType_$type } from "igniteui-react-core";
import { Thickness } from "igniteui-react-core";
import { FontInfo } from "igniteui-react-core";
import { SeriesPlotAreaMarginHorizontalMode_$type } from './SeriesPlotAreaMarginHorizontalMode';
import { SeriesPlotAreaMarginVerticalMode_$type } from './SeriesPlotAreaMarginVerticalMode';
import { IgrCalloutPlacementPositionsCollection } from './igr-callout-placement-positions-collection';
import { CalloutPlacementPositions_$type } from './CalloutPlacementPositions';
import { SeriesViewerScrollbarMode_$type } from './SeriesViewerScrollbarMode';
import { SeriesViewerHorizontalScrollbarPosition_$type } from './SeriesViewerHorizontalScrollbarPosition';
import { SeriesViewerVerticalScrollbarPosition_$type } from './SeriesViewerVerticalScrollbarPosition';
import { IgrCalloutRenderStyleUpdatingEventArgs } from './igr-callout-render-style-updating-event-args';
import { CalloutPlacementPositionsCollection as CalloutPlacementPositionsCollection_internal } from './CalloutPlacementPositionsCollection';
import { DataToolTipLayerGroupingMode_$type } from "igniteui-react-core";
import { DataTooltipGroupedPositionX_$type } from "igniteui-react-core";
import { DataTooltipGroupedPositionY_$type } from "igniteui-react-core";
import { IgrChartSummaryDescriptionCollection } from './igr-chart-summary-description-collection';
import { IgrChartSortDescriptionCollection } from './igr-chart-sort-description-collection';
import { IgrFilterExpressionCollection } from "igniteui-react-core";
import { ValueModeCollection as ValueModeCollection_internal } from './ValueModeCollection';
import { IgrValueModeCollection } from './igr-value-mode-collection';
import { ValueLayerValueMode_$type } from './ValueLayerValueMode';
export class IgrDomainChart extends React.Component {
    createImplementation() {
        return null;
    }
    get i() {
        return this._implementation;
    }
    onImplementationCreated() {
    }
    constructor(props) {
        super(props);
        this._calloutsDataSource = null;
        this._markerTypes = null;
        this._calloutsAllowedPositions = null;
        this._valueLines = null;
        this.__p = null;
        this._hasUserValues = new Set();
        this._stylingContainer = null;
        this._stylingParent = null;
        this._inStyling = false;
        this._seriesAdded = null;
        this._seriesAdded_wrapped = null;
        this._seriesRemoved = null;
        this._seriesRemoved_wrapped = null;
        this._seriesPointerEnter = null;
        this._seriesPointerEnter_wrapped = null;
        this._seriesPointerLeave = null;
        this._seriesPointerLeave_wrapped = null;
        this._seriesPointerMove = null;
        this._seriesPointerMove_wrapped = null;
        this._seriesPointerDown = null;
        this._seriesPointerDown_wrapped = null;
        this._seriesPointerUp = null;
        this._seriesPointerUp_wrapped = null;
        this._calloutStyleUpdating = null;
        this._calloutStyleUpdating_wrapped = null;
        this._calloutRenderStyleUpdating = null;
        this._calloutRenderStyleUpdating_wrapped = null;
        if (this._styling) {
            NamePatcher.ensureStylablePatched(Object.getPrototypeOf(this));
        }
        this._implementation = this.createImplementation();
        this._implementation.externalObject = this;
        this.onImplementationCreated();
    }
    componentDidMount() {
        for (const p of Object.keys(this.props)) {
            if (isValidProp(this, p)) {
                this[p] = this.props[p];
            }
        }
    }
    shouldComponentUpdate(nextProps, nextState) {
        const mod = getModifiedProps(this.props, nextProps);
        for (const p of Object.keys(mod)) {
            if (isValidProp(this, p)) {
                this[p] = mod[p];
            }
        }
        return true;
    }
    render() {
        return null;
    }
    /**
    * Sets or gets the template reference to use for tooltips for all the series.
    *
    *
    */
    get tooltipTemplate() {
        return this.i.tooltipTemplate;
    }
    set tooltipTemplate(v) {
        this.i.tooltipTemplate = v;
    }
    /**
    * Sets or gets the template references to use for tooltips for all the series, in order.
    *
    *
    */
    get tooltipTemplates() {
        let ret = [];
        if (this.i.tooltipTemplates) {
            for (let ii = 0; ii < this.i.tooltipTemplates.count; ii++) {
                ret.push(this.i.tooltipTemplates.item(ii));
            }
        }
        return ret;
    }
    set tooltipTemplates(v) {
        this.i.tooltipTemplates.clear();
        if (v) {
            for (let ii = 0; ii < v.length; ii++) {
                this.i.tooltipTemplates.add(v[ii]);
            }
        }
    }
    get legend() {
        if (this.i.legend != null)
            return this.i.legend.externalObject;
    }
    set legend(v) {
        if (v != undefined && v != null)
            this.i.legend = v.i;
    }
    set calloutsDataSource(value) {
        this._calloutsDataSource = value;
        this.bindCalloutsData();
    }
    get calloutsDataSource() {
        return this._calloutsDataSource;
    }
    bindCalloutsData() {
        if (this.i != null && this.i !== undefined) {
            this.i.calloutsItemsSource = this._calloutsDataSource;
        }
    }
    /**
 * Gets or sets the scaling value used to affect the pixel density of the control.
 * A higher scaling ratio will produce crisper visuals at the expense of memory.  Lower values will cause the control
 * to appear blurry.
*/
    get pixelScalingRatio() {
        return this.i.iq;
    }
    set pixelScalingRatio(v) {
        this.i.iq = +v;
    }
    /**
     * Gets or sets the left margin of chart title
    *
    *  Use `titleLeftMargin` property for the left margin of chart title.
    *
    * ```ts
    * this.chart.titleLeftMargin = 10;
    * ```
    *
    * ```ts
    *  <IgrCategoryChart dataSource={this.state.data}
    *                    titleLeftMargin={20}>
    *  </IgrCategoryChart>
    * ```
    */
    get titleLeftMargin() {
        return this.i.i3;
    }
    set titleLeftMargin(v) {
        this.i.i3 = +v;
    }
    /**
     * Gets or sets the right margin of chart title
    *
    *  Use `titleLeftMargin` property for the right margin of chart title.
    *
    * ```ts
    * this.chart.titleRightMargin = 10;
    * ```
    *
    * ```ts
    * <IgrCategoryChart
    * 				dataSource={this.state.data}
    *                 titleRightMargin = 10>
    *  </IgrCategoryChart>
    * ```
    */
    get titleRightMargin() {
        return this.i.i4;
    }
    set titleRightMargin(v) {
        this.i.i4 = +v;
    }
    /**
     * Gets or sets the top margin of chart title
    *
    *  Use `titleTopMargin` property for the top margin of chart title.
    *
    * ```ts
    * this.chart.titleTopMargin = 10;
    * ```
    *
    * ```ts
    * <IgrCategoryChart dataSource={this.state.data}
    *                titleTopMargin={10} />
    * ```
    */
    get titleTopMargin() {
        return this.i.i5;
    }
    set titleTopMargin(v) {
        this.i.i5 = +v;
    }
    /**
     * Gets or sets the bottom margin of chart title
    *
    *  Use `titleBottomMargin` property for the bottom margin of chart title.
    *
    * ```ts
    *  this.chart.titleBottomMargin = 5;
    * ```
    *
    * ```ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	dataSource={this.categoryData}
    * 	subtitle= "CategoryChart Subtitle"
    * 	subtitleAlignment="Right"
    * 	titleBottomMargin={5}/>
    * ```
    */
    get titleBottomMargin() {
        return this.i.i2;
    }
    set titleBottomMargin(v) {
        this.i.i2 = +v;
    }
    /**
     * Gets or sets the left margin of chart subtitle
    *
    * Use `subtitleLeftMargin` property for the left margin of chart subtitle.
    *
    * ```ts
    * this.chart.subtitleLeftMargin = 20 ;
    * ```
    *
    * ```ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	dataSource={this.categoryData}
    * 	subtitle= "CategoryChart Subtitle"
    * 	subtitleLeftMargin= {20}/>
    * ```
    */
    get subtitleLeftMargin() {
        return this.i.iy;
    }
    set subtitleLeftMargin(v) {
        this.i.iy = +v;
    }
    /**
     * Gets or sets the top margin of chart subtitle
    *
    * Use `subtitleTopMargin` property for the top margin of chart subtitle.
    *
    * ```ts
    * this.chart.subtitleTopMargin = 10;
    * ```
    *
    * ```ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	dataSource={this.categoryData}
    * 	subtitle= "CategoryChart Subtitle"
    * 	subtitleTopMargin= {10}/>
    * ```
    */
    get subtitleTopMargin() {
        return this.i.i0;
    }
    set subtitleTopMargin(v) {
        this.i.i0 = +v;
    }
    /**
     * Gets or sets the right margin of chart subtitle
    *
    * Use `subtitleRightMargin` property for the right margin of chart subtitle.
    *
    * ```ts
    *  this.chart.subtitleRightMargin = 20 ;
    * ```
    *
    * ```ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	dataSource={this.categoryData}
    * 	subtitle= "CategoryChart Subtitle"
    * 	subtitleAlignment="Right"
    * 	subtitleRightMargin ={20}/>
    * ```
    */
    get subtitleRightMargin() {
        return this.i.iz;
    }
    set subtitleRightMargin(v) {
        this.i.iz = +v;
    }
    /**
     * Gets or sets the bottom margin of chart subtitle
    *
    * Use `subtitleBottomMargin` property for the bottom margin of chart subtitle.
    *
    * ```ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	dataSource={this.categoryData}
    * 	subtitle= "CategoryChart Subtitle"
    * 	subtitleBottomMargin= {10}/>
    * ```
    *
    * ```ts
    * this.chart.subtitleBottomMargin = 10 ;
    * ```
    */
    get subtitleBottomMargin() {
        return this.i.ix;
    }
    set subtitleBottomMargin(v) {
        this.i.ix = +v;
    }
    /**
     * Gets or sets color of chart subtitle
    *
    * Use `subtitleTextColor` property to color the subtitle.
    *
    * ```ts
    * this.chart.subtitleTextColor = "#ff0000" ;
    * ```
    *
    * ```ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	dataSource={this.categoryData}
    * 	subtitle= "CategoryChart Subtitle"
    * 	subtitleTextColor="#ff0000"/>
    * ```
    */
    get subtitleTextColor() {
        return brushToString(this.i.u7);
    }
    set subtitleTextColor(v) {
        this.i.u7 = stringToBrush(v);
    }
    /**
     * Gets or sets color of chart title
    *
    *  Use `titleTextColor` property to color the chart title
    *
    * ```ts
    *  this.chart.titleTextColor="red" ;
    * ```
    *
    * ```ts
    * <IgrCategoryChart
    * 		dataSource={this.state.data}
    * 		width="700px"
    * 		height="500px"
    * 		xAxisTitle="Countries"
    * 		titleTextColor="Red" />
    *
    * ```
    */
    get titleTextColor() {
        return brushToString(this.i.u8);
    }
    set titleTextColor(v) {
        this.i.u8 = stringToBrush(v);
    }
    /**
     * Gets or sets the left margin of the chart content.
    *
    * Use the 'leftMargin' property for the left margin of the chart content.
    *
    * ```ts
    *  this.chart.leftMargin = 20;
    * ```
    *
    * ```ts
    *  <IgrCategoryChart dataSource={this.state.data}
    *                    leftMargin= {20}/>
    * ```
    */
    get leftMargin() {
        return this.i.im;
    }
    set leftMargin(v) {
        this.i.im = +v;
    }
    /**
     * Gets or sets the top margin of the chart content.
    *
    * Use `topMargin` property for the margin of the chart content.
    *
    * ```ts
    * this.chart.topMargin=20;
    * ```
    *
    * ```ts
    * <IgrCategoryChart dataSource={this.state.data}
    *                topMargin={10} />
    * ```
    */
    get topMargin() {
        return this.i.i6;
    }
    set topMargin(v) {
        this.i.i6 = +v;
    }
    /**
     * Gets or sets the right margin of the chart content.
    *
    * Use `rightMargin` property for the right margin of the chart content.
    *
    * ```ts
    *   this.chart.rightMargin = 20 ;
    * ```
    *
    * ```ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	markerTypes={this.state.markersTypes}
    * 	dataSource={this.categoryData}
    * 	rightMargin= {4}/>
    * ```
    */
    get rightMargin() {
        return this.i.iw;
    }
    set rightMargin(v) {
        this.i.iw = +v;
    }
    /**
     * Gets or sets the bottom margin around the chart content.
    *
    * Use the `bottomMargin` property for the bottom margin around the chart content.
    *
    * ```ts
    * this.chart.bottomMargin=20;
    * ```
    *
    * ```ts
    *  <IgrCategoryChart dataSource={this.state.data}
    *                    bottomMargin= 20 />
    * ```
    */
    get bottomMargin() {
        return this.i.h8;
    }
    set bottomMargin(v) {
        this.i.h8 = +v;
    }
    /**
     * Gets or sets the duration used for animating series plots when the data is changing
    *
    * Use the `TransitionDuration` property to animating between data values.
    *
    * ```ts
    * this.chart.transitionDuratio= 500;
    * ```
    *
    * ```ts
    * <IgrCategoryChart dataSource={this.state.data}
    *                transitionDuratio={500} />
    * ```
    */
    get transitionDuration() {
        return this.i.j1;
    }
    set transitionDuration(v) {
        this.i.j1 = +v;
    }
    /**
     * Gets or sets the easing function used for animating series plots when the data is changing.
     * This can be set to one of the known values "linear" or "cubic," or it can be set to an easing function which takes a single numeric parameter and returns a number.
    *
    * The 'transitionInEasingFunction' property used for easing function for animating series plots when the chart is loading into view.
    *
    * ```ts
    * this.chart.transitionInEasingFunction=  this.cubicFunc;
    *
    * cubicFunc(time: number) : number
    *   {
    *     return time;
    *   }
    * ```
    *
    * ```ts
    * <IgrCategoryChart dataSource={this.state.data}
    *                transitionInEasingFunction="cubic" />
    * ```
    */
    get transitionEasingFunction() {
        return this.i.d3;
    }
    set transitionEasingFunction(v) {
        this.i.d3 = v;
    }
    /**
     * Gets or sets CSS font property for the chart subtitle
    *
    * Use `subtitleTextStyle` property for the CSS font of the chart subtitle.
    *
    * ```ts
    * this.chart.subtitleTextStyle= "16pt Verdona";
    * ```
    *
    * ```ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	dataSource={this.categoryData}
    * 	subtitleTextStyle="16pt Verdona"/>
    * ```
    */
    get subtitleTextStyle() {
        return this.i.p7;
    }
    set subtitleTextStyle(v) {
        this.i.p7 = v;
    }
    /**
     * Gets or sets CSS font property for the chart title
    *
    * Use `titleTextStyle` property for the CSS font property of the chart title
    *
    * ```ts
    * this.chart.xAxisTitleTextStyle = "24pt Verdona";
    * ```
    *
    * ```ts
    * <IgrCategoryChart dataSource={this.state.data}
    *                 width="700px"
    *                 height="500px"
    *                 xAxisTitle="Countries"
    *                 xAxisTitleTextColor="gray"
    *                 xAxisTitleTextStyle="12pt Verdana"
    *                 xAxisTitleAngle={0}
    *                 yAxisTitle="Trillions of Watt-hours (TWh)"
    *                 yAxisTitleTextStyle="12pt Verdana"
    *                 yAxisTitleTextColor="gray"
    *                 yAxisTitleAngle={90}
    *                 yAxisTitleLeftMargin={5}>
    *  </IgrCategoryChart>
    * ```
    */
    get titleTextStyle() {
        return this.i.qi;
    }
    set titleTextStyle(v) {
        this.i.qi = v;
    }
    get dataToolTipGroupingMode() {
        return this.i.bv;
    }
    set dataToolTipGroupingMode(v) {
        this.i.bv = ensureEnum(DataToolTipLayerGroupingMode_$type, v);
    }
    /**
     * Gets or sets the offset of the tooltip layer on the X axis.
    */
    get dataToolTipPositionOffsetX() {
        return this.i.ic;
    }
    set dataToolTipPositionOffsetX(v) {
        this.i.ic = +v;
    }
    /**
     * Gets or sets the offset of the tooltip layer on the Y axis.
    */
    get dataToolTipPositionOffsetY() {
        return this.i.id;
    }
    set dataToolTipPositionOffsetY(v) {
        this.i.id = +v;
    }
    /**
     * Gets or sets the offset of the tooltip layer on the X axis.
    */
    get dataToolTipDefaultPositionOffsetX() {
        return this.i.ia;
    }
    set dataToolTipDefaultPositionOffsetX(v) {
        this.i.ia = +v;
    }
    /**
     * Gets or sets the offset of the tooltip layer on the Y axis.
    */
    get dataToolTipDefaultPositionOffsetY() {
        return this.i.ib;
    }
    set dataToolTipDefaultPositionOffsetY(v) {
        this.i.ib = +v;
    }
    /**
     * Gets or sets the tooltip position mode on the X axis for grouped series.
    */
    get dataToolTipGroupedPositionModeX() {
        return this.i.br;
    }
    set dataToolTipGroupedPositionModeX(v) {
        this.i.br = ensureEnum(DataTooltipGroupedPositionX_$type, v);
    }
    /**
     * Gets or sets the tooltip position mode on the Y axis for grouped series.
    */
    get dataToolTipGroupedPositionModeY() {
        return this.i.bt;
    }
    set dataToolTipGroupedPositionModeY(v) {
        this.i.bt = ensureEnum(DataTooltipGroupedPositionY_$type, v);
    }
    /**
     * Gets or sets whether the data legend should update when the series data is mutated.
    */
    get dataToolTipShouldUpdateWhenSeriesDataChanges() {
        return this.i.fp;
    }
    set dataToolTipShouldUpdateWhenSeriesDataChanges(v) {
        this.i.fp = ensureBool(v);
    }
    /**
     * Gets or sets indexes or names of series to include in displaying in the data legend, e.g. "0, 1"
    */
    get dataToolTipIncludedSeries() {
        return this.i.m;
    }
    set dataToolTipIncludedSeries(v) {
        if (v && !Array.isArray(v) && typeof (v) == "string") {
            const re = /\s*(?:,|\s|$)\s*/gm;
            v = v.split(re);
        }
        this.i.m = v;
    }
    /**
     * Gets or sets indexes or names of series to exclude from displaying in the data legend, e.g. "0, 1"
     * The ExcludedSeries property takes precedences over values of IncludedSeries property
    */
    get dataToolTipExcludedSeries() {
        return this.i.j;
    }
    set dataToolTipExcludedSeries(v) {
        if (v && !Array.isArray(v) && typeof (v) == "string") {
            const re = /\s*(?:,|\s|$)\s*/gm;
            v = v.split(re);
        }
        this.i.j = v;
    }
    /**
     * Gets or sets names of data columns or their labels to include in displaying in the data legend, e.g. "High, Low" or "H, L"
     * The ExcludedColumns property takes precedences over values of IncludedColumns property
    */
    get dataToolTipIncludedColumns() {
        return this.i.l;
    }
    set dataToolTipIncludedColumns(v) {
        if (v && !Array.isArray(v) && typeof (v) == "string") {
            const re = /\s*(?:,|\s|$)\s*/gm;
            v = v.split(re);
        }
        this.i.l = v;
    }
    /**
     * Gets or sets names of data columns or their labels to exclude from displaying in the data legend, e.g. "High, Low" or "H, L"
     * The ExcludedColumns property takes precedences over values of IncludedColumns property
    */
    get dataToolTipExcludedColumns() {
        return this.i.i;
    }
    set dataToolTipExcludedColumns(v) {
        if (v && !Array.isArray(v) && typeof (v) == "string") {
            const re = /\s*(?:,|\s|$)\s*/gm;
            v = v.split(re);
        }
        this.i.i = v;
    }
    /**
     * Gets or sets mode for abbreviating large numbers displayed in the legend
     * This property is ignored when setting ValueFormatSpecifiers or ValueFormatString properties
    */
    get dataToolTipValueFormatAbbreviation() {
        return this.i.bb;
    }
    set dataToolTipValueFormatAbbreviation(v) {
        this.i.bb = ensureEnum(DataAbbreviationMode_$type, v);
    }
    /**
     * Gets or sets maximum digits for formating numbers displayed in the legend
     * This property is ignored when setting ValueFormatSpecifiers or ValueFormatString properties
    */
    get dataToolTipValueFormatMaxFractions() {
        return this.i.jx;
    }
    set dataToolTipValueFormatMaxFractions(v) {
        this.i.jx = +v;
    }
    /**
     * Gets or sets minimum digits for formating numbers displayed in the legend
     * This property is ignored when setting ValueFormatSpecifiers or ValueFormatString properties
    */
    get dataToolTipValueFormatMinFractions() {
        return this.i.jy;
    }
    set dataToolTipValueFormatMinFractions(v) {
        this.i.jy = +v;
    }
    /**
     * Gets or sets the mode for displaying values in the data legend, e.g. Currency ($500.25), Decimal (500.25), Integer (500)
    */
    get dataToolTipValueFormatMode() {
        return this.i.bp;
    }
    set dataToolTipValueFormatMode(v) {
        this.i.bp = ensureEnum(DataLegendValueMode_$type, v);
    }
    /**
     * Gets or sets globalization culture when displaying values as currencies, e.g. use "en-GB" to display British pound symbol when the ValueFormatMode property is set to 'Currency' mode
     * This property is ignored when setting ValueFormatSpecifiers or ValueFormatString properties
    */
    get dataToolTipValueFormatCulture() {
        return this.i.nr;
    }
    set dataToolTipValueFormatCulture(v) {
        this.i.nr = v;
    }
    /**
     * Gets or sets whether or not use grouping separator, e.g, 15,000 for 15000
     * This property is ignored when setting ValueFormatSpecifiers or ValueFormatString properties
    */
    get dataToolTipValueFormatUseGrouping() {
        return this.i.fq;
    }
    set dataToolTipValueFormatUseGrouping(v) {
        this.i.fq = ensureBool(v);
    }
    /**
     * Gets or sets the format string for values displayed in the data legend.
    */
    get dataToolTipValueFormatString() {
        return this.i.nx;
    }
    set dataToolTipValueFormatString(v) {
        this.i.nx = v;
    }
    /**
     * Gets or sets the format specifiers to use with the ValueFormatString string.
    */
    get dataToolTipValueFormatSpecifiers() {
        return this.i.n;
    }
    set dataToolTipValueFormatSpecifiers(v) {
        if (v && !Array.isArray(v) && typeof (v) == "string") {
            const re = /\s*(?:,|\s|$)\s*/gm;
            v = v.split(re);
        }
        this.i.n = v;
    }
    get dataToolTipValueRowMarginBottom() {
        return this.i.vx ? this.i.vx.bottom : NaN;
    }
    set dataToolTipValueRowMarginBottom(v) {
        this.ensureDataToolTipValueRowMargin();
        this.i.vx.bottom = +v;
        this.i.vx = this.i.vx;
    }
    get dataToolTipValueRowMarginLeft() {
        return this.i.vx ? this.i.vx.left : NaN;
    }
    set dataToolTipValueRowMarginLeft(v) {
        this.ensureDataToolTipValueRowMargin();
        this.i.vx.left = +v;
        this.i.vx = this.i.vx;
    }
    get dataToolTipValueRowMarginRight() {
        return this.i.vx ? this.i.vx.right : NaN;
    }
    set dataToolTipValueRowMarginRight(v) {
        this.ensureDataToolTipValueRowMargin();
        this.i.vx.right = +v;
        this.i.vx = this.i.vx;
    }
    get dataToolTipValueRowMarginTop() {
        return this.i.vx ? this.i.vx.top : NaN;
    }
    set dataToolTipValueRowMarginTop(v) {
        this.ensureDataToolTipValueRowMargin();
        this.i.vx.top = +v;
        this.i.vx = this.i.vx;
    }
    ensureDataToolTipValueRowMargin() {
        if (this.i.vx) {
            return;
        }
        this.i.vx = new Thickness(2);
    }
    /**
     * Gets or sets whether to show series rows.
    */
    get dataToolTipValueRowVisible() {
        return this.i.fr;
    }
    set dataToolTipValueRowVisible(v) {
        this.i.fr = ensureBool(v);
    }
    /**
     * Gets or sets text displayed when data column is missing a value, e.g. "no data"
    */
    get dataToolTipValueTextWhenMissingData() {
        return this.i.n6;
    }
    set dataToolTipValueTextWhenMissingData(v) {
        this.i.n6 = v;
    }
    /**
     * Gets or sets whether to use series colors when displaying values in the legend
    */
    get dataToolTipValueTextUseSeriesColors() {
        return this.i.fs;
    }
    set dataToolTipValueTextUseSeriesColors(v) {
        this.i.fs = ensureBool(v);
    }
    get dataToolTipValueTextMarginBottom() {
        return this.i.vy ? this.i.vy.bottom : NaN;
    }
    set dataToolTipValueTextMarginBottom(v) {
        this.ensureDataToolTipValueTextMargin();
        this.i.vy.bottom = +v;
        this.i.vy = this.i.vy;
    }
    get dataToolTipValueTextMarginLeft() {
        return this.i.vy ? this.i.vy.left : NaN;
    }
    set dataToolTipValueTextMarginLeft(v) {
        this.ensureDataToolTipValueTextMargin();
        this.i.vy.left = +v;
        this.i.vy = this.i.vy;
    }
    get dataToolTipValueTextMarginRight() {
        return this.i.vy ? this.i.vy.right : NaN;
    }
    set dataToolTipValueTextMarginRight(v) {
        this.ensureDataToolTipValueTextMargin();
        this.i.vy.right = +v;
        this.i.vy = this.i.vy;
    }
    get dataToolTipValueTextMarginTop() {
        return this.i.vy ? this.i.vy.top : NaN;
    }
    set dataToolTipValueTextMarginTop(v) {
        this.ensureDataToolTipValueTextMargin();
        this.i.vy.top = +v;
        this.i.vy = this.i.vy;
    }
    ensureDataToolTipValueTextMargin() {
        if (this.i.vy) {
            return;
        }
        this.i.vy = new Thickness(2);
    }
    /**
     * Gets or sets the units text color.
    */
    get dataToolTipValueTextColor() {
        return brushToString(this.i.ux);
    }
    set dataToolTipValueTextColor(v) {
        this.i.ux = stringToBrush(v);
    }
    /**
     * Gets or Sets the style to use for the units text.
    */
    get dataToolTipValueTextStyle() {
        if (this.i.el == null) {
            return null;
        }
        return this.i.el.fontString;
    }
    set dataToolTipValueTextStyle(v) {
        let fi = new FontInfo();
        fi.fontString = v;
        this.i.el = fi;
    }
    /**
     * Gets or sets the format string for header text displayed in the data legend.
    */
    get dataToolTipHeaderFormatString() {
        return this.i.mh;
    }
    set dataToolTipHeaderFormatString(v) {
        this.i.mh = v;
    }
    /**
     * Gets or sets the format specifiers to use with the HeaderFormatString string.
    */
    get dataToolTipHeaderFormatSpecifiers() {
        return this.i.k;
    }
    set dataToolTipHeaderFormatSpecifiers(v) {
        if (v && !Array.isArray(v) && typeof (v) == "string") {
            const re = /\s*(?:,|\s|$)\s*/gm;
            v = v.split(re);
        }
        this.i.k = v;
    }
    /**
     * Gets or sets globalization culture when displaying header as date time
     * This property is ignored when setting HeaderFormatSpecifiers or HeaderFormatString properties
    */
    get dataToolTipHeaderFormatCulture() {
        return this.i.md;
    }
    set dataToolTipHeaderFormatCulture(v) {
        this.i.md = v;
    }
    /**
     * Gets or sets date format for the header
     * This property is ignored when setting HeaderFormatSpecifiers or HeaderFormatString properties
    */
    get dataToolTipHeaderFormatDate() {
        return this.i.bf;
    }
    set dataToolTipHeaderFormatDate(v) {
        this.i.bf = ensureEnum(DataLegendHeaderDateMode_$type, v);
    }
    /**
     * Gets or sets time format for the header
     * This property is ignored when setting HeaderFormatSpecifiers or HeaderFormatString properties
    */
    get dataToolTipHeaderFormatTime() {
        return this.i.bh;
    }
    set dataToolTipHeaderFormatTime(v) {
        this.i.bh = ensureEnum(DataLegendHeaderTimeMode_$type, v);
    }
    /**
     * Gets or sets the HeaderText for the data legend.
    */
    get dataToolTipHeaderText() {
        return this.i.mm;
    }
    set dataToolTipHeaderText(v) {
        this.i.mm = v;
    }
    /**
     * Gets or sets the header text color.
    */
    get dataToolTipHeaderTextColor() {
        return brushToString(this.i.up);
    }
    set dataToolTipHeaderTextColor(v) {
        this.i.up = stringToBrush(v);
    }
    get dataToolTipHeaderTextMarginBottom() {
        return this.i.vr ? this.i.vr.bottom : NaN;
    }
    set dataToolTipHeaderTextMarginBottom(v) {
        this.ensureDataToolTipHeaderTextMargin();
        this.i.vr.bottom = +v;
        this.i.vr = this.i.vr;
    }
    get dataToolTipHeaderTextMarginLeft() {
        return this.i.vr ? this.i.vr.left : NaN;
    }
    set dataToolTipHeaderTextMarginLeft(v) {
        this.ensureDataToolTipHeaderTextMargin();
        this.i.vr.left = +v;
        this.i.vr = this.i.vr;
    }
    get dataToolTipHeaderTextMarginRight() {
        return this.i.vr ? this.i.vr.right : NaN;
    }
    set dataToolTipHeaderTextMarginRight(v) {
        this.ensureDataToolTipHeaderTextMargin();
        this.i.vr.right = +v;
        this.i.vr = this.i.vr;
    }
    get dataToolTipHeaderTextMarginTop() {
        return this.i.vr ? this.i.vr.top : NaN;
    }
    set dataToolTipHeaderTextMarginTop(v) {
        this.ensureDataToolTipHeaderTextMargin();
        this.i.vr.top = +v;
        this.i.vr = this.i.vr;
    }
    ensureDataToolTipHeaderTextMargin() {
        if (this.i.vr) {
            return;
        }
        this.i.vr = new Thickness(2);
    }
    get dataToolTipHeaderRowMarginBottom() {
        return this.i.vq ? this.i.vq.bottom : NaN;
    }
    set dataToolTipHeaderRowMarginBottom(v) {
        this.ensureDataToolTipHeaderRowMargin();
        this.i.vq.bottom = +v;
        this.i.vq = this.i.vq;
    }
    get dataToolTipHeaderRowMarginLeft() {
        return this.i.vq ? this.i.vq.left : NaN;
    }
    set dataToolTipHeaderRowMarginLeft(v) {
        this.ensureDataToolTipHeaderRowMargin();
        this.i.vq.left = +v;
        this.i.vq = this.i.vq;
    }
    get dataToolTipHeaderRowMarginRight() {
        return this.i.vq ? this.i.vq.right : NaN;
    }
    set dataToolTipHeaderRowMarginRight(v) {
        this.ensureDataToolTipHeaderRowMargin();
        this.i.vq.right = +v;
        this.i.vq = this.i.vq;
    }
    get dataToolTipHeaderRowMarginTop() {
        return this.i.vq ? this.i.vq.top : NaN;
    }
    set dataToolTipHeaderRowMarginTop(v) {
        this.ensureDataToolTipHeaderRowMargin();
        this.i.vq.top = +v;
        this.i.vq = this.i.vq;
    }
    ensureDataToolTipHeaderRowMargin() {
        if (this.i.vq) {
            return;
        }
        this.i.vq = new Thickness(2);
    }
    /**
     * Gets or sets whether to show Header row.
    */
    get dataToolTipHeaderRowVisible() {
        return this.i.fo;
    }
    set dataToolTipHeaderRowVisible(v) {
        this.i.fo = ensureBool(v);
    }
    /**
     * Gets or Sets the style to use for the header text.
    */
    get dataToolTipHeaderTextStyle() {
        if (this.i.ed == null) {
            return null;
        }
        return this.i.ed.fontString;
    }
    set dataToolTipHeaderTextStyle(v) {
        let fi = new FontInfo();
        fi.fontString = v;
        this.i.ed = fi;
    }
    /**
     * Gets or sets the summary text color.
    */
    get dataToolTipSummaryTitleTextColor() {
        return brushToString(this.i.us);
    }
    set dataToolTipSummaryTitleTextColor(v) {
        this.i.us = stringToBrush(v);
    }
    /**
     * Gets or Sets the style to use for the summary text.
    */
    get dataToolTipSummaryTitleTextStyle() {
        if (this.i.eg == null) {
            return null;
        }
        return this.i.eg.fontString;
    }
    set dataToolTipSummaryTitleTextStyle(v) {
        let fi = new FontInfo();
        fi.fontString = v;
        this.i.eg = fi;
    }
    /**
     * Gets or sets the SummaryType for the data legend.
    */
    get dataToolTipSummaryType() {
        return this.i.bl;
    }
    set dataToolTipSummaryType(v) {
        this.i.bl = ensureEnum(DataLegendSummaryType_$type, v);
    }
    /**
     * Gets or sets the SummaryTitleText for the data legend.
    */
    get dataToolTipSummaryTitleText() {
        return this.i.m5;
    }
    set dataToolTipSummaryTitleText(v) {
        this.i.m5 = v;
    }
    get dataToolTipSummaryTitleTextMarginBottom() {
        return this.i.vu ? this.i.vu.bottom : NaN;
    }
    set dataToolTipSummaryTitleTextMarginBottom(v) {
        this.ensureDataToolTipSummaryTitleTextMargin();
        this.i.vu.bottom = +v;
        this.i.vu = this.i.vu;
    }
    get dataToolTipSummaryTitleTextMarginLeft() {
        return this.i.vu ? this.i.vu.left : NaN;
    }
    set dataToolTipSummaryTitleTextMarginLeft(v) {
        this.ensureDataToolTipSummaryTitleTextMargin();
        this.i.vu.left = +v;
        this.i.vu = this.i.vu;
    }
    get dataToolTipSummaryTitleTextMarginRight() {
        return this.i.vu ? this.i.vu.right : NaN;
    }
    set dataToolTipSummaryTitleTextMarginRight(v) {
        this.ensureDataToolTipSummaryTitleTextMargin();
        this.i.vu.right = +v;
        this.i.vu = this.i.vu;
    }
    get dataToolTipSummaryTitleTextMarginTop() {
        return this.i.vu ? this.i.vu.top : NaN;
    }
    set dataToolTipSummaryTitleTextMarginTop(v) {
        this.ensureDataToolTipSummaryTitleTextMargin();
        this.i.vu.top = +v;
        this.i.vu = this.i.vu;
    }
    ensureDataToolTipSummaryTitleTextMargin() {
        if (this.i.vu) {
            return;
        }
        this.i.vu = new Thickness(2);
    }
    get dataToolTipSummaryRowMarginBottom() {
        return this.i.vt ? this.i.vt.bottom : NaN;
    }
    set dataToolTipSummaryRowMarginBottom(v) {
        this.ensureDataToolTipSummaryRowMargin();
        this.i.vt.bottom = +v;
        this.i.vt = this.i.vt;
    }
    get dataToolTipSummaryRowMarginLeft() {
        return this.i.vt ? this.i.vt.left : NaN;
    }
    set dataToolTipSummaryRowMarginLeft(v) {
        this.ensureDataToolTipSummaryRowMargin();
        this.i.vt.left = +v;
        this.i.vt = this.i.vt;
    }
    get dataToolTipSummaryRowMarginRight() {
        return this.i.vt ? this.i.vt.right : NaN;
    }
    set dataToolTipSummaryRowMarginRight(v) {
        this.ensureDataToolTipSummaryRowMargin();
        this.i.vt.right = +v;
        this.i.vt = this.i.vt;
    }
    get dataToolTipSummaryRowMarginTop() {
        return this.i.vt ? this.i.vt.top : NaN;
    }
    set dataToolTipSummaryRowMarginTop(v) {
        this.ensureDataToolTipSummaryRowMargin();
        this.i.vt.top = +v;
        this.i.vt = this.i.vt;
    }
    ensureDataToolTipSummaryRowMargin() {
        if (this.i.vt) {
            return;
        }
        this.i.vt = new Thickness(2);
    }
    /**
     * Gets or sets the units text color.
    */
    get dataToolTipSummaryValueTextColor() {
        return brushToString(this.i.uu);
    }
    set dataToolTipSummaryValueTextColor(v) {
        this.i.uu = stringToBrush(v);
    }
    /**
     * Gets or Sets the style to use for the units text.
    */
    get dataToolTipSummaryValueTextStyle() {
        if (this.i.ei == null) {
            return null;
        }
        return this.i.ei.fontString;
    }
    set dataToolTipSummaryValueTextStyle(v) {
        let fi = new FontInfo();
        fi.fontString = v;
        this.i.ei = fi;
    }
    /**
     * Gets or sets the units text for the data legend.
    */
    get dataToolTipSummaryLabelText() {
        return this.i.m0;
    }
    set dataToolTipSummaryLabelText(v) {
        this.i.m0 = v;
    }
    /**
     * Gets or sets the units text color.
    */
    get dataToolTipSummaryLabelTextColor() {
        return brushToString(this.i.ur);
    }
    set dataToolTipSummaryLabelTextColor(v) {
        this.i.ur = stringToBrush(v);
    }
    /**
     * Gets or Sets the style to use for the units text.
    */
    get dataToolTipSummaryLabelTextStyle() {
        if (this.i.ef == null) {
            return null;
        }
        return this.i.ef.fontString;
    }
    set dataToolTipSummaryLabelTextStyle(v) {
        let fi = new FontInfo();
        fi.fontString = v;
        this.i.ef = fi;
    }
    /**
     * Gets or sets the units text for the data legend.
    */
    get dataToolTipSummaryUnitsText() {
        return this.i.nb;
    }
    set dataToolTipSummaryUnitsText(v) {
        this.i.nb = v;
    }
    /**
     * Gets or sets the units text color.
    */
    get dataToolTipSummaryUnitsTextColor() {
        return brushToString(this.i.ut);
    }
    set dataToolTipSummaryUnitsTextColor(v) {
        this.i.ut = stringToBrush(v);
    }
    /**
     * Gets or Sets the style to use for the units text.
    */
    get dataToolTipSummaryUnitsTextStyle() {
        if (this.i.eh == null) {
            return null;
        }
        return this.i.eh.fontString;
    }
    set dataToolTipSummaryUnitsTextStyle(v) {
        let fi = new FontInfo();
        fi.fontString = v;
        this.i.eh = fi;
    }
    get dataToolTipBadgeMarginBottom() {
        return this.i.vp ? this.i.vp.bottom : NaN;
    }
    set dataToolTipBadgeMarginBottom(v) {
        this.ensureDataToolTipBadgeMargin();
        this.i.vp.bottom = +v;
        this.i.vp = this.i.vp;
    }
    get dataToolTipBadgeMarginLeft() {
        return this.i.vp ? this.i.vp.left : NaN;
    }
    set dataToolTipBadgeMarginLeft(v) {
        this.ensureDataToolTipBadgeMargin();
        this.i.vp.left = +v;
        this.i.vp = this.i.vp;
    }
    get dataToolTipBadgeMarginRight() {
        return this.i.vp ? this.i.vp.right : NaN;
    }
    set dataToolTipBadgeMarginRight(v) {
        this.ensureDataToolTipBadgeMargin();
        this.i.vp.right = +v;
        this.i.vp = this.i.vp;
    }
    get dataToolTipBadgeMarginTop() {
        return this.i.vp ? this.i.vp.top : NaN;
    }
    set dataToolTipBadgeMarginTop(v) {
        this.ensureDataToolTipBadgeMargin();
        this.i.vp.top = +v;
        this.i.vp = this.i.vp;
    }
    ensureDataToolTipBadgeMargin() {
        if (this.i.vp) {
            return;
        }
        this.i.vp = new Thickness(2);
    }
    /**
     * Gets or sets the BadgeShape for the data legend.
    */
    get dataToolTipBadgeShape() {
        return this.i.ch;
    }
    set dataToolTipBadgeShape(v) {
        this.i.ch = ensureEnum(LegendItemBadgeShape_$type, v);
    }
    /**
     * Gets or sets the UnitsMode for the data legend.
    */
    get dataToolTipUnitsDisplayMode() {
        return this.i.bn;
    }
    set dataToolTipUnitsDisplayMode(v) {
        this.i.bn = ensureEnum(DataLegendUnitsMode_$type, v);
    }
    /**
     * Gets or sets the units text for the data legend.
    */
    get dataToolTipUnitsText() {
        return this.i.nl;
    }
    set dataToolTipUnitsText(v) {
        this.i.nl = v;
    }
    /**
     * Gets or sets the units text color.
    */
    get dataToolTipUnitsTextColor() {
        return brushToString(this.i.uw);
    }
    set dataToolTipUnitsTextColor(v) {
        this.i.uw = stringToBrush(v);
    }
    get dataToolTipUnitsTextMarginBottom() {
        return this.i.vw ? this.i.vw.bottom : NaN;
    }
    set dataToolTipUnitsTextMarginBottom(v) {
        this.ensureDataToolTipUnitsTextMargin();
        this.i.vw.bottom = +v;
        this.i.vw = this.i.vw;
    }
    get dataToolTipUnitsTextMarginLeft() {
        return this.i.vw ? this.i.vw.left : NaN;
    }
    set dataToolTipUnitsTextMarginLeft(v) {
        this.ensureDataToolTipUnitsTextMargin();
        this.i.vw.left = +v;
        this.i.vw = this.i.vw;
    }
    get dataToolTipUnitsTextMarginRight() {
        return this.i.vw ? this.i.vw.right : NaN;
    }
    set dataToolTipUnitsTextMarginRight(v) {
        this.ensureDataToolTipUnitsTextMargin();
        this.i.vw.right = +v;
        this.i.vw = this.i.vw;
    }
    get dataToolTipUnitsTextMarginTop() {
        return this.i.vw ? this.i.vw.top : NaN;
    }
    set dataToolTipUnitsTextMarginTop(v) {
        this.ensureDataToolTipUnitsTextMargin();
        this.i.vw.top = +v;
        this.i.vw = this.i.vw;
    }
    ensureDataToolTipUnitsTextMargin() {
        if (this.i.vw) {
            return;
        }
        this.i.vw = new Thickness(2);
    }
    /**
     * Gets or Sets the style to use for the units text.
    */
    get dataToolTipUnitsTextStyle() {
        if (this.i.ek == null) {
            return null;
        }
        return this.i.ek.fontString;
    }
    set dataToolTipUnitsTextStyle(v) {
        let fi = new FontInfo();
        fi.fontString = v;
        this.i.ek = fi;
    }
    get dataToolTipTitleTextMarginBottom() {
        return this.i.vv ? this.i.vv.bottom : NaN;
    }
    set dataToolTipTitleTextMarginBottom(v) {
        this.ensureDataToolTipTitleTextMargin();
        this.i.vv.bottom = +v;
        this.i.vv = this.i.vv;
    }
    get dataToolTipTitleTextMarginLeft() {
        return this.i.vv ? this.i.vv.left : NaN;
    }
    set dataToolTipTitleTextMarginLeft(v) {
        this.ensureDataToolTipTitleTextMargin();
        this.i.vv.left = +v;
        this.i.vv = this.i.vv;
    }
    get dataToolTipTitleTextMarginRight() {
        return this.i.vv ? this.i.vv.right : NaN;
    }
    set dataToolTipTitleTextMarginRight(v) {
        this.ensureDataToolTipTitleTextMargin();
        this.i.vv.right = +v;
        this.i.vv = this.i.vv;
    }
    get dataToolTipTitleTextMarginTop() {
        return this.i.vv ? this.i.vv.top : NaN;
    }
    set dataToolTipTitleTextMarginTop(v) {
        this.ensureDataToolTipTitleTextMargin();
        this.i.vv.top = +v;
        this.i.vv = this.i.vv;
    }
    ensureDataToolTipTitleTextMargin() {
        if (this.i.vv) {
            return;
        }
        this.i.vv = new Thickness(2);
    }
    /**
     * Gets or sets the display text color.
    */
    get dataToolTipTitleTextColor() {
        return brushToString(this.i.uv);
    }
    set dataToolTipTitleTextColor(v) {
        this.i.uv = stringToBrush(v);
    }
    /**
     * Gets or Sets the style to use for the display text.
    */
    get dataToolTipTitleTextStyle() {
        if (this.i.ej == null) {
            return null;
        }
        return this.i.ej.fontString;
    }
    set dataToolTipTitleTextStyle(v) {
        let fi = new FontInfo();
        fi.fontString = v;
        this.i.ej = fi;
    }
    /**
     * Gets or sets the mode for displaying labels before series values in the data legend, e.g. O: H: L: C: for financial series
    */
    get dataToolTipLabelDisplayMode() {
        return this.i.bj;
    }
    set dataToolTipLabelDisplayMode(v) {
        this.i.bj = ensureEnum(DataLegendLabelMode_$type, v);
    }
    /**
     * Gets or sets the units text color.
    */
    get dataToolTipLabelTextColor() {
        return brushToString(this.i.uq);
    }
    set dataToolTipLabelTextColor(v) {
        this.i.uq = stringToBrush(v);
    }
    get dataToolTipLabelTextMarginBottom() {
        return this.i.vs ? this.i.vs.bottom : NaN;
    }
    set dataToolTipLabelTextMarginBottom(v) {
        this.ensureDataToolTipLabelTextMargin();
        this.i.vs.bottom = +v;
        this.i.vs = this.i.vs;
    }
    get dataToolTipLabelTextMarginLeft() {
        return this.i.vs ? this.i.vs.left : NaN;
    }
    set dataToolTipLabelTextMarginLeft(v) {
        this.ensureDataToolTipLabelTextMargin();
        this.i.vs.left = +v;
        this.i.vs = this.i.vs;
    }
    get dataToolTipLabelTextMarginRight() {
        return this.i.vs ? this.i.vs.right : NaN;
    }
    set dataToolTipLabelTextMarginRight(v) {
        this.ensureDataToolTipLabelTextMargin();
        this.i.vs.right = +v;
        this.i.vs = this.i.vs;
    }
    get dataToolTipLabelTextMarginTop() {
        return this.i.vs ? this.i.vs.top : NaN;
    }
    set dataToolTipLabelTextMarginTop(v) {
        this.ensureDataToolTipLabelTextMargin();
        this.i.vs.top = +v;
        this.i.vs = this.i.vs;
    }
    ensureDataToolTipLabelTextMargin() {
        if (this.i.vs) {
            return;
        }
        this.i.vs = new Thickness(2);
    }
    /**
     * Gets or Sets the style to use for the units text.
    */
    get dataToolTipLabelTextStyle() {
        if (this.i.ee == null) {
            return null;
        }
        return this.i.ee.fontString;
    }
    set dataToolTipLabelTextStyle(v) {
        let fi = new FontInfo();
        fi.fontString = v;
        this.i.ee = fi;
    }
    /**
     * Gets the domain type of this chart
    */
    get domainType() {
        return this.i.b1;
    }
    /**
     * Gets the current sort that is applied to the grid. Collection can be updated to modify the sort for the grid. Once sort descriptions are in this collection, the grid will no longer listen for changes on their properties.
    */
    get sortDescriptions() {
        const r = this.i.a0;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrChartSortDescriptionCollection();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    get groupSortDescriptions() {
        const r = this.i.aw;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrChartSortDescriptionCollection();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    /**
     * Gets the current grouping that is applied to the grid. Collection can be updated to modify the grouping for the grid. Once grouping descriptions are in this collection, the grid will no longer listen for changes on their properties.
    */
    get groupDescriptions() {
        const r = this.i.av;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrChartSortDescriptionCollection();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    /**
     * Gets the current filter that is applied to the grid. Collection can be updated to modify the filter for the grid. Once filter expresisons are in this collection, the grid will no longer listen for changes on their properties.
    */
    get filterExpressions() {
        const r = this.i.dz;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrFilterExpressionCollection();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    /**
     * Gets the current summaries that are applied to the grid.
    */
    get summaryDescriptions() {
        const r = this.i.a4;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrChartSummaryDescriptionCollection();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    /**
     * Gets the initial sorts that are applied to the chart.
    */
    get initialSortDescriptions() {
        const r = this.i.az;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrChartSortDescriptionCollection();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    /**
     * Gets the initial sorts that are applied to the chart after groupings and summaries are applied.
    */
    get initialGroupSortDescriptions() {
        const r = this.i.ay;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrChartSortDescriptionCollection();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    /**
     * Gets the initial groupings that are applied to the chart.
    */
    get initialGroupDescriptions() {
        const r = this.i.ax;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrChartSortDescriptionCollection();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    /**
     * Gets the initial summaries that are applied to the chart.
    */
    get initialSummaryDescriptions() {
        const r = this.i.a3;
        if (r == null) {
            return null;
        }
        if (!r.externalObject) {
            let e = new IgrChartSummaryDescriptionCollection();
            if (r.$type) {
                e._implementation = r;
            }
            else {
                if (e.i.setNativeElement) {
                    e.i.setNativeElement(r);
                }
            }
            r.externalObject = e;
        }
        return r.externalObject;
    }
    /**
     * Gets or sets the sorts to apply to the chart. This property will become ignored if sorts are changed outside of this property.
    */
    get initialSorts() {
        return this.i.oz;
    }
    set initialSorts(v) {
        this.i.oz = v;
    }
    /**
     * Gets or sets the sorts to apply after grouping has been applied.
    */
    get groupSorts() {
        return this.i.og;
    }
    set groupSorts(v) {
        this.i.og = v;
    }
    /**
     * Gets or sets the groupings to apply to the chart. This property will become ignored if sorts are changed outside of this property.
    */
    get initialGroups() {
        return this.i.ox;
    }
    set initialGroups(v) {
        this.i.ox = v;
    }
    /**
     * Gets or sets the summaries to apply to the chart. This property will become ignored if sorts are changed outside of this property.
    */
    get initialSummaries() {
        return this.i.o1;
    }
    set initialSummaries(v) {
        this.i.o1 = v;
    }
    /**
     * Gets or sets a set of property paths that should be included for consideration by the category chart, leaving the remainder excluded. If null, all properties will be considered.
    *
    * The `IncludedProperties` property used to include the properties for the consideration of the category chart.
    *
    * ```ts
    * this.chart.includedProperties = ["ProductName", "Cost"];
    * ```
    *
    * ```ts
    * 	<IgrCategoryChart
    * 		chartType="Line"
    * 		markerTypes={this.state.markersTypes}
    * 		dataSource={this.categoryData}
    * 		excludedProperties="value" />
    * ```
    */
    get includedProperties() {
        return this.i.q;
    }
    set includedProperties(v) {
        if (v && !Array.isArray(v) && typeof (v) == "string") {
            const re = /\s*(?:,|\s|$)\s*/gm;
            v = v.split(re);
        }
        this.i.q = v;
    }
    /**
     * Gets or sets a set of property paths that should be excluded from consideration by the category chart.
    *
    * The `ExcludedProperties` property used for the property paths that should be excluded from consideration by the category chart.
    *
    * ```ts
    * this.chart.excludedProperties = ["ID", "Discount"];
    * ```
    *
    * ```ts
    * 	<IgrCategoryChart
    * 	chartType="Line"
    * 	markerTypes={this.state.markersTypes}
    * 	dataSource={this.categoryData}
    * 	excludedProperties="value" />
    * ```
    */
    get excludedProperties() {
        return this.i.o;
    }
    set excludedProperties(v) {
        if (v && !Array.isArray(v) && typeof (v) == "string") {
            const re = /\s*(?:,|\s|$)\s*/gm;
            v = v.split(re);
        }
        this.i.o = v;
    }
    /**
     * Gets or sets the palette of brushes to use for coloring the chart series.
     * The value provided should be an array of CSS color strings or JavaScript objects defining gradients. Optionally the first element can be a string reading "RGB" or "HSV" to specify the interpolation mode of the collection
    *
    * Use the `Brushes` property to  set the brushes.
    *
    * ```ts
    * this.chart.brushes = ["#ff0000","#00ff00"];
    * ```
    */
    get brushes() {
        return fromBrushCollection(this.i.ab);
    }
    set brushes(v) {
        this.i.ab = toBrushCollection(v);
    }
    /**
     * Gets or sets the palette of brushes to use for outlines on the chart series.
     * The value provided should be an array of CSS color strings or JavaScript objects defining gradients. Optionally the first element can be a string reading "RGB" or "HSV" to specify the interpolation mode of the collection
    *
    *  Use the `Outlines` property to sets the palette of brushes to use for outlines on the chart series
    *
    * ```ts
    * <IgrCategoryChart
    * 	chartType="Line"
    * 	outlines= "#ff0000"
    * 	dataSource={this.categoryData}/>
    * ```
    */
    get outlines() {
        return fromBrushCollection(this.i.af);
    }
    set outlines(v) {
        this.i.af = toBrushCollection(v);
    }
    /**
     * Gets the actual palette of brushes to use for coloring the chart series.
    */
    get actualBrushes() {
        return fromBrushCollection(this.i.z);
    }
    set actualBrushes(v) {
        this.i.z = toBrushCollection(v);
    }
    /**
     * Gets the actual palette of brushes to use for outlines on the chart series.
    */
    get actualOutlines() {
        return fromBrushCollection(this.i.aa);
    }
    set actualOutlines(v) {
        this.i.aa = toBrushCollection(v);
    }
    /**
     * Gets or sets whether the chart can be horizontally zoomed through user interactions.
    *
    * Use the `IsHorizontalZoomEnabled` property to allow chart horizontally zoomed .
    *
    * ```ts
    *  <IgrCategoryChart dataSource={this.state.data}
    *                    width="700px"
    *                    height="500px"
    *                    xAxisLabelTextStyle="10pt Verdana"
    *                    xAxisLabelTopMargin={5}
    *                    xAxisLabelTextColor="gray"
    *                    yAxisLabelTextStyle="10pt Verdana"
    *                    yAxisLabelRightMargin={5}
    *                    yAxisLabelTextColor="gray"
    * 				   isHorizontalZoomEnabled= true/>
    * ```
    *
    * ```ts
    *  <IgrCategoryChart dataSource={this.state.data}
    *                    IsHorizontalZoomEnabled= true />
    * ```
    *
    * ```ts
    * this.chart.isHorizontalZoomEnabled = true;
    * ```
    */
    get isHorizontalZoomEnabled() {
        return this.i.f2;
    }
    set isHorizontalZoomEnabled(v) {
        this.i.f2 = ensureBool(v);
    }
    /**
     * Gets or sets whether the chart can be vertically zoomed through user interactions.
    *
    * Use the `IsVerticalZoomEnabled` property to allow chart zoom vertically.
    *
    * ```ts
    *  this.chart.isVerticalZoomEnabled = true;
    * ```
    *
    * ```ts
    *  <IgrCategoryChart dataSource={this.state.data}
    *                   isVerticalZoomEnabled= "true"/>
    * ```
    */
    get isVerticalZoomEnabled() {
        return this.i.f9;
    }
    set isVerticalZoomEnabled(v) {
        this.i.f9 = ensureBool(v);
    }
    /**
     * Gets or sets whether the chart should display mock data when the data source has not been provided, if supported for this type of chart.
    */
    get shouldDisplayMockData() {
        return this.i.gc;
    }
    set shouldDisplayMockData(v) {
        this.i.gc = ensureBool(v);
    }
    /**
     * Gets or sets whether the chart should use a faded skeleton style for mock data.
    */
    get shouldUseSkeletonStyleForMockData() {
        return this.i.gf;
    }
    set shouldUseSkeletonStyleForMockData(v) {
        this.i.gf = ensureBool(v);
    }
    /**
     * Gets or sets whether the chart can highlight series through user interactions.
     * This property applies to Category Chart and Financial Chart controls.
    */
    get isSeriesHighlightingEnabled() {
        return this.i.f4;
    }
    set isSeriesHighlightingEnabled(v) {
        this.i.f4 = ensureBool(v);
    }
    /**
     * Gets or sets the rectangle representing the current scroll and zoom state of the chart.
     * WindowRect is expressed as a Rectangle with coordinates and sizes between 0 and 1.
    *
    * Use `WindowRect` property representing the current scroll and zoom state of the chart.
    *
    * ```ts
    * this.chart.windowRect =[0,0,1,1];
    * ```
    *
    * ```ts
    * <IgrCategoryChart dataSource={this.state.data}
    *                WindowRect={1,0,1,1} />
    * ```
    */
    get windowRect() {
        return fromRect(this.i.ve);
    }
    set windowRect(v) {
        this.i.ve = toRect(v);
    }
    /**
     * Gets a rectangle representing the bounds of the plot area.
    *
    * `viewport` property representing the bounds of the plot area.
    *
    * ```ts
    * let viewport:Rect =  this.chart.viewport;
    * ```
    */
    get viewport() {
        return fromRect(this.i.vd);
    }
    /**
     * Gets or sets text to display above the plot area.
    *
    * Use the `Title` property to display the text above the plot area.
    *
    * ```ts
    *  this.chart.title= "This is a Title";
    * ```
    *
    * ```ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	dataSource={this.categoryData}
    * 	title= "CategoryChart Subtitle"	/>
    * ```
    */
    get chartTitle() {
        return this.i.qb;
    }
    set chartTitle(v) {
        this.i.qb = v;
    }
    /**
     * Gets or sets text to display below the Title, above the plot area.
    *
    * Use the `Subtitle` property to display the text below  and above the plot area.
    *
    * ```ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	dataSource={this.categoryData}
    * 	subtitle= "CategoryChart Subtitle"/>
    * ```
    *
    * ```ts
    *  this.chart.subtitle ="CategoryChart Subtitle" ;
    * ```
    */
    get subtitle() {
        return this.i.p0;
    }
    set subtitle(v) {
        this.i.p0 = v;
    }
    /**
     * Gets or sets horizontal alignment which determines the title position, relative to the left and right edges of the control.
    *
    * Use the `TitleAlignment` property for the horizontal alignment of the title.
    *
    * ```ts
    * this.chart.titleAlignment = HorizontalAlignment.Center;
    * ```
    *
    * ```ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	dataSource={this.categoryData}
    * 	titleAlignment= "Center"/>
    * ```
    */
    get titleAlignment() {
        return this.i.tv;
    }
    set titleAlignment(v) {
        this.i.tv = ensureEnum(HorizontalAlignment_$type, v);
    }
    /**
     * Gets or sets horizontal alignment which determines the subtitle position, relative to the left and right edges of the control.
    *
    * Use the `SubtitleAlignment` property to Gets or sets horizontal alignment.
    *
    * ```ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	dataSource={this.categoryData}
    * 	subtitle= "CategoryChart Subtitle"
    * 	subtitleAlignment="Right"/>
    * ```
    *
    * ```ts
    * this.chart.subtitleAlignment = HorizontalAlignment.Right;
    * ```
    */
    get subtitleAlignment() {
        return this.i.tu;
    }
    set subtitleAlignment(v) {
        this.i.tu = ensureEnum(HorizontalAlignment_$type, v);
    }
    /**
     * Gets or sets the behavior that determines how unknown values will be plotted on the chart.
     * Null and Double.NaN are two examples of unknown values.
    *
    * Use the `UnknownValuePlotting` property to determines the behavior that how unknown values will be plotted on the chart.
    *
    * ```ts
    * this.chart.unknownValuePlotting =UnknownValuePlotting.DontPlot;
    * ```
    *
    * ```ts
    * <IgrCategoryChart dataSource={this.state.data}
    *                unknownValuePlotting= "dontPlot" />
    * ```
    */
    get unknownValuePlotting() {
        return this.i.ds;
    }
    set unknownValuePlotting(v) {
        this.i.ds = ensureEnum(UnknownValuePlotting_$type, v);
    }
    /**
     * Gets or sets the rendering resolution for all series in this chart.
     * Where n = Resolution, for every n horizontal pixels, combine all items into a single data point.  When Resolution = 0, all data points will be rendered as graphical objects.  Charts with a higher resolution will have faster performance.
    *
    * Use the `Resolution` property if the callouts should be display.
    *
    * ```ts
    *   this.chart.resolution = 2 ;
    * ```
    *
    * ```ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	markerTypes={this.state.markersTypes}
    * 	dataSource={this.categoryData}
    * 	calloutsVisible="true"
    * 	resolution= {2}/>
    * ```
    */
    get resolution() {
        return this.i.iv;
    }
    set resolution(v) {
        this.i.iv = +v;
    }
    /**
     * Gets or sets the thickness for all series in this chart. Depending on the ChartType, this can be the main brush used, or just the outline.
    *
    * Use the `Thickness` property for the thickness of all the series in this chart.
    */
    get thickness() {
        return this.i.i1;
    }
    set thickness(v) {
        this.i.i1 = +v;
    }
    /**
     * Gets or sets the OutlineMode for all series in this chart.
    */
    get outlineMode() {
        return this.i.c9;
    }
    set outlineMode(v) {
        this.i.c9 = ensureEnum(SeriesOutlineMode_$type, v);
    }
    /**
     * Gets or sets the MarkerOutlineMode for all series that support markers in this chart.
    */
    get markerOutlineMode() {
        return this.i.co;
    }
    set markerOutlineMode(v) {
        this.i.co = ensureEnum(MarkerOutlineMode_$type, v);
    }
    /**
     * Gets or sets the MarkerFillMode for all series that support markers in this chart.
    */
    get markerFillMode() {
        return this.i.cm;
    }
    set markerFillMode(v) {
        this.i.cm = ensureEnum(MarkerFillMode_$type, v);
    }
    /**
     * Gets or sets the Marker Fill Opacity for all series that support markers in this chart.
    */
    get markerFillOpacity() {
        return this.i.io;
    }
    set markerFillOpacity(v) {
        this.i.io = +v;
    }
    /**
     * Gets or sets the Marker Thickness for all series that support markers in this chart.
    */
    get markerThickness() {
        return this.i.ip;
    }
    set markerThickness(v) {
        this.i.ip = +v;
    }
    /**
     * Gets or sets the marker shapes used for indicating location of data points in this chart.
     * This property applies only to these chart types: point, line, spline, bubble, and polygon
    */
    get markerTypes() {
        if (this._markerTypes === null) {
            let coll = new IgrMarkerTypeCollection();
            let innerColl = this.i.cu;
            if (!innerColl) {
                innerColl = new MarkerTypeCollection_internal();
            }
            this._markerTypes = coll._fromInner(innerColl);
            this.i.cu = innerColl;
        }
        return this._markerTypes;
    }
    set markerTypes(v) {
        if (this._markerTypes !== null) {
            this._markerTypes._setSyncTarget(null);
            this._markerTypes = null;
        }
        let coll = new IgrMarkerTypeCollection();
        this._markerTypes = coll._fromOuter(v);
        let syncColl = new SyncableObservableCollection$1(MarkerType_$type);
        let innerColl = this.i.cu;
        if (!innerColl) {
            innerColl = new MarkerTypeCollection_internal();
        }
        syncColl._inner = innerColl;
        syncColl.clear();
        this._markerTypes._setSyncTarget(syncColl);
        this.i.cu = innerColl;
    }
    /**
     * Gets or sets the default marker type for all series plotted in this chart.
     * This property is ignored when the MarkerTypes property is set
    */
    get markerAutomaticBehavior() {
        return this.i.ck;
    }
    set markerAutomaticBehavior(v) {
        this.i.ck = ensureEnum(MarkerAutomaticBehavior_$type, v);
    }
    /**
     * Gets or sets the palette of brushes used for rendering fill area of data point markers.
     * This property applies only to these chart types: point, line, spline, bubble, and polygon
    *
    * `MarkerBrushes` property used for rendering fill area of data point markers.
    *
    * ```ts
    *  this.chart.markerBrushes=[ "#ff0000", "#ffff00", "#00ffff" ];
    * ```
    *
    * ```ts
    * <IgrCategoryChart
    *     chartType="Line"
    *     markerBrushes ="#ffff00"
    *     dataSource={this.categoryData}/>
    * ```
    */
    get markerBrushes() {
        return fromBrushCollection(this.i.ad);
    }
    set markerBrushes(v) {
        this.i.ad = toBrushCollection(v);
    }
    /**
     * Gets or sets the palette of brushes used for rendering outlines of data point markers.
     * This property applies only to these chart types: point, line, spline, bubble, and polygon
    *
    * `MarkerOutlines` property used for rendering outlines of data point markers.
    *
    * ```ts
    * this.chart.markerOutlines= ["#ff0000", "#ffff00", "#00ffff"] ;
    * ```
    *
    * ```ts
    * <IgrCategoryChart
    * 	chartType="Line"
    * 	markerOutlines= "#ff0000"
    * 	dataSource={this.categoryData}/>
    * ```
    */
    get markerOutlines() {
        return fromBrushCollection(this.i.ae);
    }
    set markerOutlines(v) {
        this.i.ae = toBrushCollection(v);
    }
    /**
     * Gets or sets the maximum number of markers displayed in the plot area of the chart.
    *
    * `markerMaxCount` property used to display maximum number of markers in the plot area of the chart.
    *
    * ```ts
    *  this.chart.markerMaxCount = 100 ;
    * ```
    *
    * ```ts
    * <IgrCategoryChart
    * 	chartType="Line"
    * 	markerMaxCount= {2}
    * 	dataSource={this.categoryData}/>
    * ```
    */
    get markerMaxCount() {
        return this.i.j0;
    }
    set markerMaxCount(v) {
        this.i.j0 = +v;
    }
    /**
     * Gets or sets the fill opacity for all series that have area visuals in this chart.
     * For example, Area, SplineArea, Column chart types
    */
    get areaFillOpacity() {
        return this.i.h7;
    }
    set areaFillOpacity(v) {
        this.i.h7 = +v;
    }
    /**
     * Gets or sets whether the series animations should be allowed when a range change has been detected on an axis.
    */
    get animateSeriesWhenAxisRangeChanges() {
        return this.i.fh;
    }
    set animateSeriesWhenAxisRangeChanges(v) {
        this.i.fh = ensureBool(v);
    }
    /**
     * Gets or sets the palette of brushes to used for coloring trend lines in this chart.
     * The value provided should be an array of CSS color strings or JavaScript objects defining gradients. Optionally the first element can be a string reading "RGB" or "HSV" to specify the interpolation mode of the collection
    *
    * Use the `TrendLineBrushes` property for coloring trend lines in the chart.
    *
    * ```ts
    * this.chart.trendLineBrushes=["#ff0000", "#ffff00", "#00ffff"]	;
    * ```
    *
    * ```ts
    * <IgrCategoryChart dataSource={this.state.data}
    *                trendLineBrushes="#ffff00" />
    * ```
    */
    get trendLineBrushes() {
        return fromBrushCollection(this.i.ah);
    }
    set trendLineBrushes(v) {
        this.i.ah = toBrushCollection(v);
    }
    /**
     * Gets or sets the formula used for calculating trend lines in this chart.
     * This property applies only to these chart types: point, line, spline, and bubble
    *
    * Use the `TrendLineType` property for calculating trend lines.
    *
    * ```ts
    * this.chart.trendLineType = TrendLineType.CubicFit;
    * ```
    *
    * ```ts
    * <IgrCategoryChart dataSource={this.state.data}
    *                trendLineType="CubicFit" />
    * ```
    */
    get trendLineType() {
        return this.i.dq;
    }
    set trendLineType(v) {
        this.i.dq = ensureEnum(TrendLineType_$type, v);
    }
    /**
     * Gets or sets the thickness of the trend lines in this chart.
     * This property applies only to these chart types: point, line, spline, and bubble
    *
    * Use the `TrendLineThickness` property for the thickness of the trend lines in the chart.
    *
    * ```ts
    * this.chart.trendLineThickness=2;
    * ```
    *
    * ```ts
    * <IgrCategoryChart dataSource={this.state.data}
    *                trendLineThickness={2} />
    * ```
    */
    get trendLineThickness() {
        return this.i.i7;
    }
    set trendLineThickness(v) {
        this.i.i7 = +v;
    }
    /**
     * Gets or sets a value indicating whether grid and tick lines are aligned to device pixels.
    *
    * Use `AlignsGridLinesToPixels` propert to indicat whether grid and tick lines are aligned to device pixels.
    *
    * ```ts
    *  this.chart.alignsGridLinesToPixels= true;
    * ```
    */
    get alignsGridLinesToPixels() {
        return this.i.fg;
    }
    set alignsGridLinesToPixels(v) {
        this.i.fg = ensureBool(v);
    }
    /**
     * Margin applied to the Left of the plot area.
    */
    get plotAreaMarginLeft() {
        return this.i.is;
    }
    set plotAreaMarginLeft(v) {
        this.i.is = +v;
    }
    /**
     * Margin applied to the Top of the plot area.
    */
    get plotAreaMarginTop() {
        return this.i.iu;
    }
    set plotAreaMarginTop(v) {
        this.i.iu = +v;
    }
    /**
     * Margin applied to the right of the plot area.
    */
    get plotAreaMarginRight() {
        return this.i.it;
    }
    set plotAreaMarginRight(v) {
        this.i.it = +v;
    }
    /**
     * Margin applied below the plot area.
    */
    get plotAreaMarginBottom() {
        return this.i.ir;
    }
    set plotAreaMarginBottom(v) {
        this.i.ir = +v;
    }
    /**
     * Gets or sets mode to use for automatically calculating the plot area margin.
    */
    get computedPlotAreaMarginMode() {
        return this.i.a6;
    }
    set computedPlotAreaMarginMode(v) {
        this.i.a6 = ensureEnum(ComputedPlotAreaMarginMode_$type, v);
    }
    /**
     * Gets or sets horizontal mode to use for automatically calculating the plot area margin based ont the series.
    */
    get seriesPlotAreaMarginHorizontalMode() {
        return this.i.db;
    }
    set seriesPlotAreaMarginHorizontalMode(v) {
        this.i.db = ensureEnum(SeriesPlotAreaMarginHorizontalMode_$type, v);
    }
    /**
     * Gets or sets vertical mode to use for automatically calculating the plot area margin based ont the series.
    */
    get seriesPlotAreaMarginVerticalMode() {
        return this.i.dd;
    }
    set seriesPlotAreaMarginVerticalMode(v) {
        this.i.dd = ensureEnum(SeriesPlotAreaMarginVerticalMode_$type, v);
    }
    /**
     * Gets or sets the highlighting mode to use for the series in the component, when supported. This takes precedence over the series level IsHightlightingEnabled.
    */
    get highlightingMode() {
        return this.i.c7;
    }
    set highlightingMode(v) {
        this.i.c7 = ensureEnum(SeriesHighlightingMode_$type, v);
    }
    /**
     * Gets or sets the highlighting Behavior to use for the series in the component, when supported. This takes precedence over the series level IsHightlightingEnabled.
    */
    get highlightingBehavior() {
        return this.i.c5;
    }
    set highlightingBehavior(v) {
        this.i.c5 = ensureEnum(SeriesHighlightingBehavior_$type, v);
    }
    /**
     * Gets or sets the highlighting mode to use for the legend linked to the component, when supported.
    */
    get legendHighlightingMode() {
        return this.i.cc;
    }
    set legendHighlightingMode(v) {
        this.i.cc = ensureEnum(LegendHighlightingMode_$type, v);
    }
    /**
     * Gets or sets the type of legend badges representing all series displayed in a legend linked to this component
     * This property will be ignored when the LegendItemTemplate or LegendItemBadgeTemplate property is set on a series
    */
    get legendItemBadgeShape() {
        return this.i.ci;
    }
    set legendItemBadgeShape(v) {
        this.i.ci = ensureEnum(LegendItemBadgeShape_$type, v);
    }
    /**
     * Gets or sets the mode of legend badges representing all series displayed in a legend linked to this component.
     * This property will be ignored when the LegendItemTemplate or LegendItemBadgeTemplate property is set on a series
    */
    get legendItemBadgeMode() {
        return this.i.ce;
    }
    set legendItemBadgeMode(v) {
        this.i.ce = ensureEnum(LegendItemBadgeMode_$type, v);
    }
    get trendLinePeriod() {
        return this.i.j2;
    }
    set trendLinePeriod(v) {
        this.i.j2 = +v;
    }
    /**
     * Gets or sets the style of tooltip to be displayed.
    */
    get toolTipType() {
        return this.i.dn;
    }
    set toolTipType(v) {
        this.i.dn = ensureEnum(ToolTipType_$type, v);
    }
    /**
     * Gets or sets the crosshairs to be displayed.
    */
    get crosshairsDisplayMode() {
        return this.i.a9;
    }
    set crosshairsDisplayMode(v) {
        this.i.a9 = ensureEnum(CrosshairsDisplayMode_$type, v);
    }
    /**
     * Gets or sets whether crosshairs will snap to the nearest data point.
    */
    get crosshairsSnapToData() {
        return this.i.fn;
    }
    set crosshairsSnapToData(v) {
        this.i.fn = ensureBool(v);
    }
    /**
     * Gets or sets the color to apply to vertical crosshairs line.
    */
    get crosshairsLineVerticalStroke() {
        return brushToString(this.i.uo);
    }
    set crosshairsLineVerticalStroke(v) {
        this.i.uo = stringToBrush(v);
    }
    /**
     * Gets or sets thickness of crosshairs lines.
    */
    get crosshairsLineThickness() {
        return this.i.h9;
    }
    set crosshairsLineThickness(v) {
        this.i.h9 = +v;
    }
    /**
     * Gets or sets the color to apply to horizontal crosshairs line.
    */
    get crosshairsLineHorizontalStroke() {
        return brushToString(this.i.un);
    }
    set crosshairsLineHorizontalStroke(v) {
        this.i.un = stringToBrush(v);
    }
    /**
     * Gets or sets whether annotations are shown along the axis for crosshair values
    */
    get crosshairsAnnotationEnabled() {
        return this.i.fm;
    }
    set crosshairsAnnotationEnabled(v) {
        this.i.fm = ensureBool(v);
    }
    /**
     * Gets or sets the background of crosshair annotation on x-axis.
    */
    get crosshairsAnnotationXAxisBackground() {
        return brushToString(this.i.uj);
    }
    set crosshairsAnnotationXAxisBackground(v) {
        this.i.uj = stringToBrush(v);
    }
    /**
     * Gets or sets the background of crosshair annotation on y-axis.
    */
    get crosshairsAnnotationYAxisBackground() {
        return brushToString(this.i.ul);
    }
    set crosshairsAnnotationYAxisBackground(v) {
        this.i.ul = stringToBrush(v);
    }
    /**
     * Gets or sets the text color of crosshair annotation on x-axis.
    */
    get crosshairsAnnotationXAxisTextColor() {
        return brushToString(this.i.uk);
    }
    set crosshairsAnnotationXAxisTextColor(v) {
        this.i.uk = stringToBrush(v);
    }
    /**
     * Gets or sets the text color of crosshair annotation on y-axis.
    */
    get crosshairsAnnotationYAxisTextColor() {
        return brushToString(this.i.um);
    }
    set crosshairsAnnotationYAxisTextColor(v) {
        this.i.um = stringToBrush(v);
    }
    /**
     * Gets or sets precision on interpolated values of crosshairs on x-axis.
    */
    get crosshairsAnnotationXAxisPrecision() {
        return this.i.jv;
    }
    set crosshairsAnnotationXAxisPrecision(v) {
        this.i.jv = +v;
    }
    /**
     * Gets or sets precision on interpolated values of crosshairs on y-axis.
    */
    get crosshairsAnnotationYAxisPrecision() {
        return this.i.jw;
    }
    set crosshairsAnnotationYAxisPrecision(v) {
        this.i.jw = +v;
    }
    /**
     * Gets or sets whether annotations for the final value of each series is displayed on the axis.
    */
    get shouldAvoidAxisAnnotationCollisions() {
        return this.i.gb;
    }
    set shouldAvoidAxisAnnotationCollisions(v) {
        this.i.gb = ensureBool(v);
    }
    /**
     * Gets or sets a whether the chart should pan its content when zooing in passed max zoom level.
    */
    get shouldPanOnMaximumZoom() {
        return this.i.gd;
    }
    set shouldPanOnMaximumZoom(v) {
        this.i.gd = ensureBool(v);
    }
    /**
     * Gets or sets whether annotations for the final value of each series is displayed on the axis.
    */
    get finalValueAnnotationsVisible() {
        return this.i.ft;
    }
    set finalValueAnnotationsVisible(v) {
        this.i.ft = ensureBool(v);
    }
    /**
     * Gets or sets the background of final value annotation.
    */
    get finalValueAnnotationsBackground() {
        return brushToString(this.i.uy);
    }
    set finalValueAnnotationsBackground(v) {
        this.i.uy = stringToBrush(v);
    }
    /**
     * Gets or sets the text color of final value annotation.
    */
    get finalValueAnnotationsTextColor() {
        return brushToString(this.i.uz);
    }
    set finalValueAnnotationsTextColor(v) {
        this.i.uz = stringToBrush(v);
    }
    /**
     * Gets or sets precision on final value annotation.
    */
    get finalValueAnnotationsPrecision() {
        return this.i.jz;
    }
    set finalValueAnnotationsPrecision(v) {
        this.i.jz = +v;
    }
    /**
     * Gets or sets if the auto value callouts should be displayed.
    */
    get autoCalloutsVisible() {
        return this.i.fj;
    }
    set autoCalloutsVisible(v) {
        this.i.fj = ensureBool(v);
    }
    /**
     * Gets or sets if callouts should be displayed.
    */
    get calloutsVisible() {
        return this.i.fl;
    }
    set calloutsVisible(v) {
        this.i.fl = ensureBool(v);
    }
    /**
     * Gets or sets if event annotations should be displayed.
    */
    get calloutStyleUpdatingEventEnabled() {
        return this.i.fk;
    }
    set calloutStyleUpdatingEventEnabled(v) {
        this.i.fk = ensureBool(v);
    }
    /**
     * Gets or sets the allowed positions that the callout layer is allowed to use.
    */
    get calloutsAllowedPositions() {
        if (this._calloutsAllowedPositions === null) {
            let coll = new IgrCalloutPlacementPositionsCollection();
            let innerColl = this.i.ak;
            if (!innerColl) {
                innerColl = new CalloutPlacementPositionsCollection_internal();
            }
            this._calloutsAllowedPositions = coll._fromInner(innerColl);
            this.i.ak = innerColl;
        }
        return this._calloutsAllowedPositions;
    }
    set calloutsAllowedPositions(v) {
        if (this._calloutsAllowedPositions !== null) {
            this._calloutsAllowedPositions._setSyncTarget(null);
            this._calloutsAllowedPositions = null;
        }
        let coll = new IgrCalloutPlacementPositionsCollection();
        this._calloutsAllowedPositions = coll._fromOuter(v);
        let syncColl = new SyncableObservableCollection$1(CalloutPlacementPositions_$type);
        let innerColl = this.i.ak;
        if (!innerColl) {
            innerColl = new CalloutPlacementPositionsCollection_internal();
        }
        syncColl._inner = innerColl;
        syncColl.clear();
        this._calloutsAllowedPositions._setSyncTarget(syncColl);
        this.i.ak = innerColl;
    }
    /**
     * Gets or sets the member path of the X data for the callouts.
    */
    get calloutsXMemberPath() {
        return this.i.lm;
    }
    set calloutsXMemberPath(v) {
        this.i.lm = v;
    }
    /**
     * Gets or sets the member path of the Y data for the callouts.
    */
    get calloutsYMemberPath() {
        return this.i.lo;
    }
    set calloutsYMemberPath(v) {
        this.i.lo = v;
    }
    /**
     * Gets or sets the member path of the label data for the callouts.
    */
    get calloutsLabelMemberPath() {
        return this.i.li;
    }
    set calloutsLabelMemberPath(v) {
        this.i.li = v;
    }
    /**
     * Gets or sets the member path of the content data for the callouts.
    */
    get calloutsContentMemberPath() {
        return this.i.lf;
    }
    set calloutsContentMemberPath(v) {
        this.i.lf = v;
    }
    /**
     * Gets or sets what value lines to use in the chart.
    */
    get valueLines() {
        if (this._valueLines === null) {
            let coll = new IgrValueModeCollection();
            let innerColl = this.i.du;
            if (!innerColl) {
                innerColl = new ValueModeCollection_internal();
            }
            this._valueLines = coll._fromInner(innerColl);
            this.i.du = innerColl;
        }
        return this._valueLines;
    }
    set valueLines(v) {
        if (this._valueLines !== null) {
            this._valueLines._setSyncTarget(null);
            this._valueLines = null;
        }
        let coll = new IgrValueModeCollection();
        this._valueLines = coll._fromOuter(v);
        let syncColl = new SyncableObservableCollection$1(ValueLayerValueMode_$type);
        let innerColl = this.i.du;
        if (!innerColl) {
            innerColl = new ValueModeCollection_internal();
        }
        syncColl._inner = innerColl;
        syncColl.clear();
        this._valueLines._setSyncTarget(syncColl);
        this.i.du = innerColl;
    }
    /**
     * Gets or sets the palette of brushes to use for coloring the value lines present in the ValueLines property.
     * The value provided should be an array of CSS color strings or JavaScript objects defining gradients. Optionally the first element can be a string reading "RGB" or "HSV" to specify the interpolation mode of the collection
    */
    get valueLinesBrushes() {
        return fromBrushCollection(this.i.ai);
    }
    set valueLinesBrushes(v) {
        this.i.ai = toBrushCollection(v);
    }
    /**
     * Gets or sets thickness of value lines.
    */
    get valueLinesThickness() {
        return this.i.i8;
    }
    set valueLinesThickness(v) {
        this.i.i8 = +v;
    }
    /**
     * Gets or sets the horizontal scrollbar mode to use for the series viewer.
    */
    get horizontalViewScrollbarMode() {
        return this.i.di;
    }
    set horizontalViewScrollbarMode(v) {
        this.i.di = ensureEnum(SeriesViewerScrollbarMode_$type, v);
    }
    /**
     * Gets or sets the vertical scrollbar mode to use for the series viewer.
    */
    get verticalViewScrollbarMode() {
        return this.i.dj;
    }
    set verticalViewScrollbarMode(v) {
        this.i.dj = ensureEnum(SeriesViewerScrollbarMode_$type, v);
    }
    /**
     * Gets or sets the position to use for the horizontal scrollbar in the component, when enabled.
    */
    get horizontalViewScrollbarPosition() {
        return this.i.df;
    }
    set horizontalViewScrollbarPosition(v) {
        this.i.df = ensureEnum(SeriesViewerHorizontalScrollbarPosition_$type, v);
    }
    /**
     * Gets or sets the position to use for the vertical scrollbar in the component, when enabled.
    */
    get verticalViewScrollbarPosition() {
        return this.i.dl;
    }
    set verticalViewScrollbarPosition(v) {
        this.i.dl = ensureEnum(SeriesViewerVerticalScrollbarPosition_$type, v);
    }
    /**
     * Gets or sets the fill to use for the horizontal scrollbar in the component, when enabled.
    */
    get horizontalViewScrollbarFill() {
        return brushToString(this.i.u4);
    }
    set horizontalViewScrollbarFill(v) {
        this.i.u4 = stringToBrush(v);
    }
    /**
     * Gets or sets the outline to use for the horizontal scrollbar in the component, when enabled.
    */
    get horizontalViewScrollbarOutline() {
        return brushToString(this.i.u5);
    }
    set horizontalViewScrollbarOutline(v) {
        this.i.u5 = stringToBrush(v);
    }
    /**
     * Gets or sets the stroke thickness to use for the horizontal scrollbar in the component, when enabled.
    */
    get horizontalViewScrollbarStrokeThickness() {
        return this.i.ij;
    }
    set horizontalViewScrollbarStrokeThickness(v) {
        this.i.ij = +v;
    }
    /**
     * Gets or sets the max opacity to use for the horizontal scrollbar in the component, when enabled.
    */
    get horizontalViewScrollbarMaxOpacity() {
        return this.i.ii;
    }
    set horizontalViewScrollbarMaxOpacity(v) {
        this.i.ii = +v;
    }
    /**
     * Gets or sets the corner radius to use for the horizontal scrollbar in the component, when enabled.
    */
    get horizontalViewScrollbarCornerRadius() {
        return this.i.ie;
    }
    set horizontalViewScrollbarCornerRadius(v) {
        this.i.ie = +v;
    }
    /**
     * Gets or sets the height to use for the horizontal scrollbar in the component, when enabled.
    */
    get horizontalViewScrollbarHeight() {
        return this.i.ig;
    }
    set horizontalViewScrollbarHeight(v) {
        this.i.ig = +v;
    }
    /**
     * Gets or sets the inset distance to use for the horizontal scrollbar in the component, when enabled.
    */
    get horizontalViewScrollbarInset() {
        return this.i.ih;
    }
    set horizontalViewScrollbarInset(v) {
        this.i.ih = +v;
    }
    /**
     * Gets or sets the track start inset to use for the horizontal scrollbar in the component, when enabled.
    */
    get horizontalViewScrollbarTrackStartInset() {
        return this.i.il;
    }
    set horizontalViewScrollbarTrackStartInset(v) {
        this.i.il = +v;
    }
    /**
     * Gets or sets the track end inset to use for the horizontal scrollbar in the component, when enabled.
    */
    get horizontalViewScrollbarTrackEndInset() {
        return this.i.ik;
    }
    set horizontalViewScrollbarTrackEndInset(v) {
        this.i.ik = +v;
    }
    /**
     * Gets or sets whether to use automatic track insets for the horizontal scrollbar in the component, when enabled.
    */
    get horizontalViewScrollbarShouldAddAutoTrackInsets() {
        return this.i.fv;
    }
    set horizontalViewScrollbarShouldAddAutoTrackInsets(v) {
        this.i.fv = ensureBool(v);
    }
    /**
     * Gets or sets the fill to use for the vertical scrollbar in the component, when enabled.
    */
    get verticalViewScrollbarFill() {
        return brushToString(this.i.u9);
    }
    set verticalViewScrollbarFill(v) {
        this.i.u9 = stringToBrush(v);
    }
    /**
     * Gets or sets the outline to use for the vertical scrollbar in the component, when enabled.
    */
    get verticalViewScrollbarOutline() {
        return brushToString(this.i.va);
    }
    set verticalViewScrollbarOutline(v) {
        this.i.va = stringToBrush(v);
    }
    /**
     * Gets or sets the stroke thickness to use for the vertical scrollbar in the component, when enabled.
    */
    get verticalViewScrollbarStrokeThickness() {
        return this.i.jc;
    }
    set verticalViewScrollbarStrokeThickness(v) {
        this.i.jc = +v;
    }
    /**
     * Gets or sets the max opacity to use for the vertical scrollbar in the component, when enabled.
    */
    get verticalViewScrollbarMaxOpacity() {
        return this.i.jb;
    }
    set verticalViewScrollbarMaxOpacity(v) {
        this.i.jb = +v;
    }
    /**
     * Gets or sets the corner radius to use for the vertical scrollbar in the component, when enabled.
    */
    get verticalViewScrollbarCornerRadius() {
        return this.i.i9;
    }
    set verticalViewScrollbarCornerRadius(v) {
        this.i.i9 = +v;
    }
    /**
     * Gets or sets the width to use for the vertical scrollbar in the component, when enabled.
    */
    get verticalViewScrollbarWidth() {
        return this.i.jf;
    }
    set verticalViewScrollbarWidth(v) {
        this.i.jf = +v;
    }
    /**
     * Gets or sets the inset distance to use for the vertical scrollbar in the component, when enabled.
    */
    get verticalViewScrollbarInset() {
        return this.i.ja;
    }
    set verticalViewScrollbarInset(v) {
        this.i.ja = +v;
    }
    /**
     * Gets or sets the track start inset to use for the vertical scrollbar in the component, when enabled.
    */
    get verticalViewScrollbarTrackStartInset() {
        return this.i.je;
    }
    set verticalViewScrollbarTrackStartInset(v) {
        this.i.je = +v;
    }
    /**
     * Gets or sets the track end inset to use for the vertical scrollbar in the component, when enabled.
    */
    get verticalViewScrollbarTrackEndInset() {
        return this.i.jd;
    }
    set verticalViewScrollbarTrackEndInset(v) {
        this.i.jd = +v;
    }
    /**
     * Gets or sets whether to use automatic track insets for the vertical scrollbar in the component, when enabled.
    */
    get verticalViewScrollbarShouldAddAutoTrackInsets() {
        return this.i.gg;
    }
    set verticalViewScrollbarShouldAddAutoTrackInsets(v) {
        this.i.gg = ensureBool(v);
    }
    /**
     * Sets or gets the minimum width that the window rect is allowed to reach before being clamped.
     * Decrease this value if you want to allow for further zooming into the viewer.
     * If this value is lowered too much it can cause graphical corruption due to floating point arithmetic inaccuracy.
     * This property accepts values between 0.0 (max zooming) and 1.0 (no zooming)
    */
    get windowRectMinWidth() {
        return this.i.jh;
    }
    set windowRectMinWidth(v) {
        this.i.jh = +v;
    }
    /**
     * Sets or gets the minimum height that the window rect is allowed to reach before being clamped.
     * Decrease this value if you want to allow for further zooming into the viewer.
     * If this value is lowered too much it can cause graphical corruption due to floating point arithmetic inaccuracy.
     * This property accepts values between 0.0 (max zooming) and 1.0 (no zooming)
    */
    get windowRectMinHeight() {
        return this.i.jg;
    }
    set windowRectMinHeight(v) {
        this.i.jg = +v;
    }
    /**
     * Sets or gets minimum pixel width that the window is allowed to reach before being clamped.
     * Decrease this value if you want to allow for further zooming into the viewer.
     * If this value is lowered too much it can cause graphical corruption due to floating point arithmetic inaccuracy.
     * This property is overridden by the WindowRectMinWidth property
    */
    get windowSizeMinWidth() {
        return this.i.jj;
    }
    set windowSizeMinWidth(v) {
        this.i.jj = +v;
    }
    /**
     * Sets or gets minimum pixel height that the window is allowed to reach before being clamped.
     * Decrease this value if you want to allow for further zooming into the viewer.
     * If this value is lowered too much it can cause graphical corruption due to floating point arithmetic inaccuracy.
     * This property is overridden by the WindowRectMinHeight property
    */
    get windowSizeMinHeight() {
        return this.i.ji;
    }
    set windowSizeMinHeight(v) {
        this.i.ji = +v;
    }
    findByName(name) {
        if (this.findEphemera) {
            if (name && name.indexOf("@@e:") == 0) {
                return this.findEphemera(name);
            }
        }
        if (this.dataToolTipValueFormatSpecifiers != null && arrayFindByName(this.dataToolTipValueFormatSpecifiers, name)) {
            return arrayFindByName(this.dataToolTipValueFormatSpecifiers, name);
        }
        if (this.dataToolTipHeaderFormatSpecifiers != null && arrayFindByName(this.dataToolTipHeaderFormatSpecifiers, name)) {
            return arrayFindByName(this.dataToolTipHeaderFormatSpecifiers, name);
        }
        if (this.sortDescriptions != null && this.sortDescriptions.findByName && this.sortDescriptions.findByName(name)) {
            return this.sortDescriptions.findByName(name);
        }
        if (this.groupSortDescriptions != null && this.groupSortDescriptions.findByName && this.groupSortDescriptions.findByName(name)) {
            return this.groupSortDescriptions.findByName(name);
        }
        if (this.groupDescriptions != null && this.groupDescriptions.findByName && this.groupDescriptions.findByName(name)) {
            return this.groupDescriptions.findByName(name);
        }
        if (this.filterExpressions != null && this.filterExpressions.findByName && this.filterExpressions.findByName(name)) {
            return this.filterExpressions.findByName(name);
        }
        if (this.summaryDescriptions != null && this.summaryDescriptions.findByName && this.summaryDescriptions.findByName(name)) {
            return this.summaryDescriptions.findByName(name);
        }
        if (this.initialSortDescriptions != null && this.initialSortDescriptions.findByName && this.initialSortDescriptions.findByName(name)) {
            return this.initialSortDescriptions.findByName(name);
        }
        if (this.initialGroupSortDescriptions != null && this.initialGroupSortDescriptions.findByName && this.initialGroupSortDescriptions.findByName(name)) {
            return this.initialGroupSortDescriptions.findByName(name);
        }
        if (this.initialGroupDescriptions != null && this.initialGroupDescriptions.findByName && this.initialGroupDescriptions.findByName(name)) {
            return this.initialGroupDescriptions.findByName(name);
        }
        if (this.initialSummaryDescriptions != null && this.initialSummaryDescriptions.findByName && this.initialSummaryDescriptions.findByName(name)) {
            return this.initialSummaryDescriptions.findByName(name);
        }
        if (this.legend && this.legend.name && this.legend.name == name) {
            return this.legend;
        }
        if (this.markerTypes != null && this.markerTypes.findByName && this.markerTypes.findByName(name)) {
            return this.markerTypes.findByName(name);
        }
        if (this.calloutsAllowedPositions != null && this.calloutsAllowedPositions.findByName && this.calloutsAllowedPositions.findByName(name)) {
            return this.calloutsAllowedPositions.findByName(name);
        }
        if (this.valueLines != null && this.valueLines.findByName && this.valueLines.findByName(name)) {
            return this.valueLines.findByName(name);
        }
        return null;
    }
    get hasUserValues() {
        return this._hasUserValues;
    }
    __m(propertyName) {
        if (!this._inStyling) {
            this._hasUserValues.add(propertyName);
        }
    }
    _styling(container, component, parent) {
        if (this._inStyling) {
            return;
        }
        this._inStyling = true;
        this._stylingContainer = container;
        this._stylingParent = component;
        let genericPrefix = "";
        let typeName = this.i.$type.name;
        if (typeName.indexOf("Xam") === 0) {
            typeName = typeName.substring(3);
        }
        genericPrefix = toSpinal("DomainChart");
        let additionalPrefixes = [];
        let prefix = toSpinal(typeName);
        additionalPrefixes.push(prefix + "-");
        let b = this.i.$type.baseType;
        while (b && b.name != "Object" &&
            b.name != "Base" &&
            b.name != "Control" &&
            b.Name != "DependencyObject" &&
            b.Name != "FrameworkElement") {
            typeName = b.name;
            if (typeName.indexOf("Xam") === 0) {
                typeName = typeName.substring(3);
            }
            let basePrefix = toSpinal(typeName);
            additionalPrefixes.push(basePrefix + "-");
            b = b.baseType;
        }
        if (parent) {
            let parentTypeName = parent.i.$type.name;
            if (parentTypeName.indexOf("Xam") === 0) {
                parentTypeName = parentTypeName.substring(3);
            }
            let parentPrefix = toSpinal(parentTypeName);
            additionalPrefixes.push(parentPrefix + "-" + genericPrefix + "-");
            additionalPrefixes.push(parentPrefix + "-" + prefix + "-");
        }
        initializePropertiesFromCss(container, this, genericPrefix + "-", this.hasUserValues, false, additionalPrefixes);
        if (this._otherStyling) {
            this._otherStyling(container, component, parent);
        }
        this._inStyling = false;
    }
    /**
 * Provides a container for this control

*
* `provideContainer` method provide container for the control.
*
* ```ts
*     this.chart.provideContainer("Container");
* ```
*/
    provideContainer(container) {
        this.i.provideContainer(container);
    }
    /**
     * Destroy this control
    
    *
    * Use the `destroy` property to destroy the chart.
    *
    * ```ts
    * this.chart.destroy();
    * ```
    */
    destroy() {
        this.i.destroy();
    }
    /**
     * Called when the control has been resized.
    
    *
    * `NotifyResized` method Called when the control has been resized.
    *
    * ```ts
    * this.chart.notifyResized();
    * ```
    */
    notifyResized() {
        this.i.notifyResized();
    }
    notifyVisualPropertiesChanged() {
        this.i.sl();
    }
    /**
     * Forces any pending refresh to the chart to be finished.
    
    *
    * Method `flush` used to Forces any pending deferred work to render on the chart before continuing.
    *
    * ```ts
    * this.chart.flush();
    * ```
    */
    flush() {
        this.i.rs();
    }
    /**
     * Hides the active main tooltip, if displayed.
    
    *
    * Use the `HideToolTip` method to hide the active tooltip.
    *
    * ```ts
    * this.chart.hideToolTip();
    * ```
    */
    hideToolTip() {
        this.i.r0();
    }
    /**
     * Replays transition-in animation on all series in the chart.
    
    */
    replayTransitionIn() {
        this.i.te();
    }
    /**
     * Performs zoom in action on the chart by specified percentage of current window rect
    
    */
    zoomIn(percentage) {
        this.i.tq(percentage);
    }
    /**
     * Performs zoom out action on the chart by specified percentage of current window rect
    
    */
    zoomOut(percentage) {
        this.i.tr(percentage);
    }
    /**
     * Resets the zoom level to default.
    
    */
    resetZoom() {
        this.i.tm();
    }
    getDesiredToolbarActions() {
        let iv = this.i.getDesiredToolbarActions();
        return (iv);
    }
    onToolCommandExecuting(command) {
        this.i.onToolCommandExecuting(command);
    }
    addCommandAvailabilityListener(listener) {
        this.i.addCommandAvailabilityListener(listener);
    }
    removeCommandAvailabilityListener(listener) {
        this.i.removeCommandAvailabilityListener(listener);
    }
    addCommandStateChangedListener(listener) {
        this.i.addCommandStateChangedListener(listener);
    }
    removeCommandStateChangedListener(listener) {
        this.i.removeCommandStateChangedListener(listener);
    }
    notifySetItem(source_, index, oldItem, newItem) {
        this.i.sk(source_, index, oldItem, newItem);
    }
    /**
     * Used to manually notify the chart that the data source has reset or cleared its items.
    
    *
    * Use `notifyClearItems` method to notifies the chart that the items have been cleared from an associated data source.
    *
    * ```ts
    * this.chart.notifyClearItems(this.data);
    * ```
    */
    notifyClearItems(source_) {
        this.i.sg(source_);
    }
    notifyInsertItem(source_, index, newItem) {
        this.i.sh(source_, index, newItem);
    }
    notifyRemoveItem(source_, index, oldItem) {
        this.i.si(source_, index, oldItem);
    }
    /**
     * Event raised when a series is initialized and added to this chart.
    *
    * `SeriesAdded` event raised when a series is initialized and added to this chart.
    *
    * ````ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	markerTypes={this.state.markersTypes}
    * 	dataSource={this.categoryData}
    * 	seriesAdded={this.CategoryChart_SeriesAdded}/>
    * ``
    *
    * ```ts
    * CategoryChart_SeriesAdded(sender:any ,aregs:ChartSeriesEventArgs)
    * {
    * }
    * ````
    */
    get seriesAdded() {
        return this._seriesAdded;
    }
    set seriesAdded(ev) {
        if (this._seriesAdded_wrapped !== null) {
            this.i.seriesAdded = delegateRemove(this.i.seriesAdded, this._seriesAdded_wrapped);
            this._seriesAdded_wrapped = null;
            this._seriesAdded = null;
        }
        this._seriesAdded = ev;
        this._seriesAdded_wrapped = (o, e) => {
            let outerArgs = new IgrChartSeriesEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeSeriesAdded) {
                this.beforeSeriesAdded(this, outerArgs);
            }
            if (this._seriesAdded) {
                this._seriesAdded(this, outerArgs);
            }
        };
        this.i.seriesAdded = delegateCombine(this.i.seriesAdded, this._seriesAdded_wrapped);
        ;
    }
    /**
     * Event raised when a series is removed from this chart.
    *
    * `SeriesRemoved` event raised when a series is removed from this chart.
    *
    * ```ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	markerTypes={this.state.markersTypes}
    * 	dataSource={this.categoryData}
    * 	seriesRemoved={this.CategoryChart_seriesRemoved}/>
    * ```
    *
    * ```ts
    *  CategoryChart_seriesRemoved(sender: any , aregs: ChartSeriesEventArgs)
    *   {
    *
    *   }
    * ```
    */
    get seriesRemoved() {
        return this._seriesRemoved;
    }
    set seriesRemoved(ev) {
        if (this._seriesRemoved_wrapped !== null) {
            this.i.seriesRemoved = delegateRemove(this.i.seriesRemoved, this._seriesRemoved_wrapped);
            this._seriesRemoved_wrapped = null;
            this._seriesRemoved = null;
        }
        this._seriesRemoved = ev;
        this._seriesRemoved_wrapped = (o, e) => {
            let outerArgs = new IgrChartSeriesEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeSeriesRemoved) {
                this.beforeSeriesRemoved(this, outerArgs);
            }
            if (this._seriesRemoved) {
                this._seriesRemoved(this, outerArgs);
            }
        };
        this.i.seriesRemoved = delegateCombine(this.i.seriesRemoved, this._seriesRemoved_wrapped);
        ;
    }
    /**
     * Occurs when the pointer enters a Series.
    *
    * `SeriesPointerEnter` event raised when the pointer enters a Series.
    *
    * ```ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	markerTypes={this.state.markersTypes}
    * 	dataSource={this.categoryData}
    * 	seriesPointerEnter={this.CategoryChart_seriesPointerDown}/>
    * ```
    *
    * ```ts
    * CategoryChart_seriesPointerEnter(sender: any , aregs: ChartSeriesEventArgs)
    *   {
    *
    *   }
    * ```
    */
    get seriesPointerEnter() {
        return this._seriesPointerEnter;
    }
    set seriesPointerEnter(ev) {
        if (this._seriesPointerEnter_wrapped !== null) {
            this.i.seriesPointerEnter = delegateRemove(this.i.seriesPointerEnter, this._seriesPointerEnter_wrapped);
            this._seriesPointerEnter_wrapped = null;
            this._seriesPointerEnter = null;
        }
        this._seriesPointerEnter = ev;
        this._seriesPointerEnter_wrapped = (o, e) => {
            let outerArgs = new IgrDomainChartSeriesPointerEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeSeriesPointerEnter) {
                this.beforeSeriesPointerEnter(this, outerArgs);
            }
            if (this._seriesPointerEnter) {
                this._seriesPointerEnter(this, outerArgs);
            }
        };
        this.i.seriesPointerEnter = delegateCombine(this.i.seriesPointerEnter, this._seriesPointerEnter_wrapped);
        ;
    }
    /**
     * Occurs when the pointer leaves a Series.
    *
    * `SeriesPointerLeave` event raised when the pointer leaves a Series.
    *
    * ```ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	markerTypes={this.state.markersTypes}
    * 	dataSource={this.categoryData}
    * 	seriesPointerLeave={this.CategoryChart_seriesPointerLeave}/>
    * ```
    *
    * ```ts
    * CategoryChart_seriesPointerLeave(sender: any , aregs: ChartSeriesEventArgs)
    *   {
    *
    *   }
    * ```
    */
    get seriesPointerLeave() {
        return this._seriesPointerLeave;
    }
    set seriesPointerLeave(ev) {
        if (this._seriesPointerLeave_wrapped !== null) {
            this.i.seriesPointerLeave = delegateRemove(this.i.seriesPointerLeave, this._seriesPointerLeave_wrapped);
            this._seriesPointerLeave_wrapped = null;
            this._seriesPointerLeave = null;
        }
        this._seriesPointerLeave = ev;
        this._seriesPointerLeave_wrapped = (o, e) => {
            let outerArgs = new IgrDomainChartSeriesPointerEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeSeriesPointerLeave) {
                this.beforeSeriesPointerLeave(this, outerArgs);
            }
            if (this._seriesPointerLeave) {
                this._seriesPointerLeave(this, outerArgs);
            }
        };
        this.i.seriesPointerLeave = delegateCombine(this.i.seriesPointerLeave, this._seriesPointerLeave_wrapped);
        ;
    }
    /**
     * Occurs when the pointer moves over a Series.
    *
    * `SeriesPointerMove` event raised when the pointer moves over a Series.
    *
    * ```ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	markerTypes={this.state.markersTypes}
    * 	dataSource={this.categoryData}
    * 	seriesPointerMove={this.CategoryChart_seriesPointerMove}/>
    * ```
    *
    * ```ts
    *  CategoryChart_seriesPointerMove(sender: any , aregs: ChartSeriesEventArgs)
    *   {
    *
    *   }
    * ```
    */
    get seriesPointerMove() {
        return this._seriesPointerMove;
    }
    set seriesPointerMove(ev) {
        if (this._seriesPointerMove_wrapped !== null) {
            this.i.seriesPointerMove = delegateRemove(this.i.seriesPointerMove, this._seriesPointerMove_wrapped);
            this._seriesPointerMove_wrapped = null;
            this._seriesPointerMove = null;
        }
        this._seriesPointerMove = ev;
        this._seriesPointerMove_wrapped = (o, e) => {
            let outerArgs = new IgrDomainChartSeriesPointerEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeSeriesPointerMove) {
                this.beforeSeriesPointerMove(this, outerArgs);
            }
            if (this._seriesPointerMove) {
                this._seriesPointerMove(this, outerArgs);
            }
        };
        this.i.seriesPointerMove = delegateCombine(this.i.seriesPointerMove, this._seriesPointerMove_wrapped);
        ;
    }
    /**
     * Occurs when the pointer is pressed down over a Series.
    *
    * `SeriesPointerDown` event raised when the pointer is pressed down over a Series
    *
    * ````ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	markerTypes={this.state.markersTypes}
    * 	dataSource={this.categoryData}
    * 	seriesPointerDown={this.CategoryChart_seriesPointerDown}/>
    * ``
    *
    * ```ts
    * CategoryChart_seriesPointerDown(sender: any , aregs: ChartSeriesEventArgs)
    *   {
    *
    *   }
    * ````
    */
    get seriesPointerDown() {
        return this._seriesPointerDown;
    }
    set seriesPointerDown(ev) {
        if (this._seriesPointerDown_wrapped !== null) {
            this.i.seriesPointerDown = delegateRemove(this.i.seriesPointerDown, this._seriesPointerDown_wrapped);
            this._seriesPointerDown_wrapped = null;
            this._seriesPointerDown = null;
        }
        this._seriesPointerDown = ev;
        this._seriesPointerDown_wrapped = (o, e) => {
            let outerArgs = new IgrDomainChartSeriesPointerEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeSeriesPointerDown) {
                this.beforeSeriesPointerDown(this, outerArgs);
            }
            if (this._seriesPointerDown) {
                this._seriesPointerDown(this, outerArgs);
            }
        };
        this.i.seriesPointerDown = delegateCombine(this.i.seriesPointerDown, this._seriesPointerDown_wrapped);
        ;
    }
    /**
     * Occurs when the pointer is released over a Series.
    *
    * `SeriesPointerUp` event raised when the pointer is released over a Series.
    *
    * ```ts
    *  <IgrCategoryChart
    * 	width="100%"
    * 	height="100%"
    * 	chartType="Line"
    * 	markerTypes={this.state.markersTypes}
    * 	dataSource={this.categoryData}
    * 	seriesPointerUp={this.CategoryChart_seriesPointerUp}/>
    * ```
    *
    * ```ts
    *  CategoryChart_seriesPointerUp(sender: any , aregs: ChartSeriesEventArgs)
    *   {
    *
    *   }
    * ```
    */
    get seriesPointerUp() {
        return this._seriesPointerUp;
    }
    set seriesPointerUp(ev) {
        if (this._seriesPointerUp_wrapped !== null) {
            this.i.seriesPointerUp = delegateRemove(this.i.seriesPointerUp, this._seriesPointerUp_wrapped);
            this._seriesPointerUp_wrapped = null;
            this._seriesPointerUp = null;
        }
        this._seriesPointerUp = ev;
        this._seriesPointerUp_wrapped = (o, e) => {
            let outerArgs = new IgrDomainChartSeriesPointerEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeSeriesPointerUp) {
                this.beforeSeriesPointerUp(this, outerArgs);
            }
            if (this._seriesPointerUp) {
                this._seriesPointerUp(this, outerArgs);
            }
        };
        this.i.seriesPointerUp = delegateCombine(this.i.seriesPointerUp, this._seriesPointerUp_wrapped);
        ;
    }
    /**
     * Occurs when the style of a callout is updated.
    */
    get calloutStyleUpdating() {
        return this._calloutStyleUpdating;
    }
    set calloutStyleUpdating(ev) {
        if (this._calloutStyleUpdating_wrapped !== null) {
            this.i.calloutStyleUpdating = delegateRemove(this.i.calloutStyleUpdating, this._calloutStyleUpdating_wrapped);
            this._calloutStyleUpdating_wrapped = null;
            this._calloutStyleUpdating = null;
        }
        this._calloutStyleUpdating = ev;
        this._calloutStyleUpdating_wrapped = (o, e) => {
            let outerArgs = new IgrCalloutStyleUpdatingEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeCalloutStyleUpdating) {
                this.beforeCalloutStyleUpdating(this, outerArgs);
            }
            if (this._calloutStyleUpdating) {
                this._calloutStyleUpdating(this, outerArgs);
            }
        };
        this.i.calloutStyleUpdating = delegateCombine(this.i.calloutStyleUpdating, this._calloutStyleUpdating_wrapped);
        ;
    }
    /**
     * Occurs when the style of a callout is updated.
    */
    get calloutRenderStyleUpdating() {
        return this._calloutRenderStyleUpdating;
    }
    set calloutRenderStyleUpdating(ev) {
        if (this._calloutRenderStyleUpdating_wrapped !== null) {
            this.i.calloutRenderStyleUpdating = delegateRemove(this.i.calloutRenderStyleUpdating, this._calloutRenderStyleUpdating_wrapped);
            this._calloutRenderStyleUpdating_wrapped = null;
            this._calloutRenderStyleUpdating = null;
        }
        this._calloutRenderStyleUpdating = ev;
        this._calloutRenderStyleUpdating_wrapped = (o, e) => {
            let outerArgs = new IgrCalloutRenderStyleUpdatingEventArgs();
            outerArgs._provideImplementation(e);
            if (this.beforeCalloutRenderStyleUpdating) {
                this.beforeCalloutRenderStyleUpdating(this, outerArgs);
            }
            if (this._calloutRenderStyleUpdating) {
                this._calloutRenderStyleUpdating(this, outerArgs);
            }
        };
        this.i.calloutRenderStyleUpdating = delegateCombine(this.i.calloutRenderStyleUpdating, this._calloutRenderStyleUpdating_wrapped);
        ;
    }
}
